<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>hbyyy&#39;s blog</title>
    <link>https://hbyyy.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 19 May 2020 13:45:58 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>python_datastructure_ch3_1_20200519</title>
      <link>https://hbyyy.github.io/2020/05/19/python-datastructure-ch3-1-20200519/</link>
      <guid>https://hbyyy.github.io/2020/05/19/python-datastructure-ch3-1-20200519/</guid>
      <pubDate>Tue, 19 May 2020 13:44:54 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;이번 포스트에서는 컬렉션 자료구조인 셋과 딕셔너리에 대해 정리할 것이다.&lt;/p&gt;
&lt;p&gt;컬렉션 자료구조는 세 가지 속성을 가진다&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;멤버십 연산자 : in&lt;/strong&gt;, &lt;strong&gt;크기 함수 : len&lt;/strong&gt;, &lt;strong&gt;반복성&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;셋&quot;&gt;&lt;a href=&quot;#셋&quot; class=&quot;headerlink&quot; title=&quot;셋&quot;&gt;&lt;/a&gt;셋&lt;/h2&gt;&lt;p&gt; &lt;strong&gt;셋&lt;/strong&gt;은 반복 가능, 가변적, 중복 요소 없음, 정렬되지 않음 특성을 가진 데이터 타입이다. 주도 &lt;strong&gt;멤버십 테스트&lt;/strong&gt;, &lt;strong&gt;중복 제거&lt;/strong&gt; 를 할 때 사용한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>이번 포스트에서는 컬렉션 자료구조인 셋과 딕셔너리에 대해 정리할 것이다.</p><p>컬렉션 자료구조는 세 가지 속성을 가진다</p><p><strong>멤버십 연산자 : in</strong>, <strong>크기 함수 : len</strong>, <strong>반복성</strong></p></blockquote><h2 id="셋"><a href="#셋" class="headerlink" title="셋"></a>셋</h2><p> <strong>셋</strong>은 반복 가능, 가변적, 중복 요소 없음, 정렬되지 않음 특성을 가진 데이터 타입이다. 주도 <strong>멤버십 테스트</strong>, <strong>중복 제거</strong> 를 할 때 사용한다.</p><a id="more"></a><h3 id="셋-메서드"><a href="#셋-메서드" class="headerlink" title="셋 메서드"></a>셋 메서드</h3><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><p>A.add(x) 는 셋 A에 x가 없을 경우 x를 추가한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>&#125;</span><br><span class="line">s.add(<span class="string">"4"</span>)</span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># 셋은 순서가 없다</span></span><br><span class="line">Out : &#123;<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"2"</span>, <span class="string">"4"</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="update-union"><a href="#update-union" class="headerlink" title="update(), union()"></a>update(), union()</h4><ul><li><p>A.update(B) (A |= B)는  셋 A에 셋 B를 추가한다. </p></li><li><p>A.union(x)(A | B) 은 update와 같지만, 연산 결과를 복사본으로 반환한다.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;</span><br><span class="line">B = &#123;<span class="string">"3"</span>, <span class="string">"4"</span>&#125;</span><br><span class="line"><span class="comment"># update() 메서드</span></span><br><span class="line">A.update(B)</span><br><span class="line">print(A)</span><br><span class="line">Out : &#123;<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># union() 메서드</span></span><br><span class="line">A = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;</span><br><span class="line">C = A.union(B)</span><br><span class="line">print(C)</span><br><span class="line">Out : &#123;<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="intersection-difference-clear"><a href="#intersection-difference-clear" class="headerlink" title="intersection(), difference(). clear()"></a>intersection(), difference(). clear()</h4><ul><li>A.intersection(B)(A&amp;B) 는 A와 B의 교집합의 복사본을 반환한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;</span><br><span class="line">B = &#123;<span class="string">"1"</span>, <span class="string">"3"</span>&#125;</span><br><span class="line">C = A.intersection(B)</span><br><span class="line">print(C)</span><br><span class="line">Out : &#123;<span class="string">'1'</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>A.difference(A-B) 는 A와 B의 차집합의 복사본을 반환한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;</span><br><span class="line">B = &#123;<span class="string">"1"</span>, <span class="string">"3"</span>&#125;</span><br><span class="line">C = A.difference(B)</span><br><span class="line">print(C)</span><br><span class="line">Out : &#123;<span class="string">'2'</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>A.clear()는 A의 모든 항목을 제거한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;</span><br><span class="line">A.clear()</span><br><span class="line">print(A)</span><br><span class="line">Out : &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="discard-remove"><a href="#discard-remove" class="headerlink" title="discard(), remove()"></a>discard(), remove()</h4><ul><li>A.discard(x)는 A의 항목 x를 제거한다. 반환값은  항상 None 이다.</li><li>A.remove(x)는 discard와 같지만, x가 A에 없을 때 KeyError를 발생시킨다.</li></ul><h2 id="딕셔너리"><a href="#딕셔너리" class="headerlink" title="딕셔너리"></a>딕셔너리</h2><p>딕셔너리는 해시 테이블로 구현되어 있다. 셋과 마찬가지로  반복 가능, 가변적, 중복 요소 없음, 정렬되지 않음 특성을 가지고 <strong>키와 값</strong>으로 매핑된 항목의 컬렉션이다.</p><blockquote><p>파이썬 3.7부터는 항목의 삽입 순서를 보존한다.</p></blockquote><h3 id="딕셔너리-메서드"><a href="#딕셔너리-메서드" class="headerlink" title="딕셔너리 메서드"></a>딕셔너리 메서드</h3><h4 id="update-get"><a href="#update-get" class="headerlink" title="update(), get()"></a>update(), get()</h4><ul><li><p>A.update(B) 는 딕셔너리 A에 딕셔너리 B를 추가해 준다. 만약 A에 B의 키가 존재한다면, 기존 키의 값을 업데이트</p></li><li><p>A.get(key, default=None) 은 딕셔너리 A에서 key의 값을 반환한다. key가 없다면 default 값을 반환한다</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = &#123;<span class="number">1</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">2</span>, <span class="number">3</span>:<span class="number">3</span>&#125;</span><br><span class="line">print(A.get(<span class="number">1</span>))</span><br><span class="line">Out : <span class="number">1</span></span><br><span class="line">print(A.get(<span class="number">5</span>))</span><br><span class="line">Out : <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="pop-popitem"><a href="#pop-popitem" class="headerlink" title="pop(), popitem()"></a>pop(), popitem()</h4><ul><li>A.pop(key) 는 key 항목을 제거한 후 반환한다.</li><li>A.popitem()은 A에서 한개의 항목을 제거한 후 반환한다.</li></ul><h4 id="keys-values-items"><a href="#keys-values-items" class="headerlink" title="keys(), values(), items()"></a>keys(), values(), items()</h4><p>딕셔너리의 항목을 조회한다. 각각 키, 값, 키와 값을 반환하는데, 주로 반복문에서 사용한다. </p>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/19/python-datastructure-ch3-1-20200519/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TIL-20200519</title>
      <link>https://hbyyy.github.io/2020/05/19/TIL-20200519/</link>
      <guid>https://hbyyy.github.io/2020/05/19/TIL-20200519/</guid>
      <pubDate>Tue, 19 May 2020 13:42:58 GMT</pubDate>
      <description>
      
        
        
          &lt;ol&gt;
&lt;li&gt;파이썬 자료구조와 알고리즘&lt;ul&gt;
&lt;li&gt;CH 7 연습문제 풀이  (반정도 완료)&lt;/li&gt;
&lt;li&gt;파이썬 컬렉션 자료구조 (셋, 딕셔너리) 복습, 정리&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;

        
      
      </description>
      
      
      <content:encoded><![CDATA[<ol><li>파이썬 자료구조와 알고리즘<ul><li>CH 7 연습문제 풀이  (반정도 완료)</li><li>파이썬 컬렉션 자료구조 (셋, 딕셔너리) 복습, 정리</li></ul></li></ol>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/19/TIL-20200519/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TIL-20200518</title>
      <link>https://hbyyy.github.io/2020/05/18/TIL-20200518/</link>
      <guid>https://hbyyy.github.io/2020/05/18/TIL-20200518/</guid>
      <pubDate>Mon, 18 May 2020 13:14:57 GMT</pubDate>
      <description>
      
        
        
          &lt;ol&gt;
&lt;li&gt;&lt;p&gt;파이썬 자료구조와 알고리즘&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CH 7 뒷부분 완료 (우선순위 큐, 연결 리스트)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Github action&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;develop 브랜치에 커밋될 때에도
        
      
      </description>
      
      
      <content:encoded><![CDATA[<ol><li><p>파이썬 자료구조와 알고리즘</p><ul><li>CH 7 뒷부분 완료 (우선순위 큐, 연결 리스트)</li></ul></li><li><p>Github action</p><ul><li>develop 브랜치에 커밋될 때에도 실행되도록 수정</li></ul></li><li><p>Netflex project</p><ul><li>base.py에서 secretmanaget 불러오는 코드 간결하게 수정<ul><li>aws credential 파일에 변경사항 있음!</li></ul></li></ul></li></ol>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/18/TIL-20200518/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 자료구조와 알고리즘 - 추상 데이터 타입(우선순위 큐, 연결 리스트)</title>
      <link>https://hbyyy.github.io/2020/05/18/python-datastructure-ch7-2-20200518/</link>
      <guid>https://hbyyy.github.io/2020/05/18/python-datastructure-ch7-2-20200518/</guid>
      <pubDate>Mon, 18 May 2020 10:52:47 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;이번 포스트에서는 우선순위 큐, 연결 리스트에 대해 정리할 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;우선순위-큐와-힙&quot;&gt;&lt;a href=&quot;#우선순위-큐와-힙&quot; class=&quot;headerlink&quot; title=&quot;우선순위 큐와 힙&quot;&gt;&lt;/a&gt;우선순위 큐와 힙&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;우선순위 큐는 항목마다 우선순위가 있고, 우선순위가 같으면 큐의 순서를 따른다&lt;/li&gt;
&lt;li&gt;우선순위 큐는 주로 힙을 사용해 구현한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;힙&quot;&gt;&lt;a href=&quot;#힙&quot; class=&quot;headerlink&quot; title=&quot;힙&quot;&gt;&lt;/a&gt;힙&lt;/h3&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>이번 포스트에서는 우선순위 큐, 연결 리스트에 대해 정리할 것이다.</p></blockquote><h2 id="우선순위-큐와-힙"><a href="#우선순위-큐와-힙" class="headerlink" title="우선순위 큐와 힙"></a>우선순위 큐와 힙</h2><ul><li>우선순위 큐는 항목마다 우선순위가 있고, 우선순위가 같으면 큐의 순서를 따른다</li><li>우선순위 큐는 주로 힙을 사용해 구현한다.</li></ul><h3 id="힙"><a href="#힙" class="headerlink" title="힙"></a>힙</h3><a id="more"></a><p><img src="https://gmlwjd9405.github.io/images/data-structure-heap/types-of-heap.png" alt="img"></p><ul><li>힙은 각 노드가 하위 노드보다 작은 or 큰 이진 트리이다.</li></ul><p>리스트에서 가장 작은(또는 큰) 값에 반복적으로 접근해햐 한다면 힙이 유용하다.</p><p>최대 힙, 최소 힙에서 각각 최댓값, 최솟값은 루트 노드에 위치하고 있으니, 이 요소를 처리하는 시간복잡도는 O(1)이다. </p><p>조회, 추가, 수정을 처리하는 시간복잡도는 O(logn)이다. </p><h3 id="heapq-모듈"><a href="#heapq-모듈" class="headerlink" title="heapq 모듈"></a>heapq 모듈</h3><p>파이썬에는 힙 자료구조를 사용할 수 있는 heapq 모듈이 존재한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">h = []</span><br><span class="line"><span class="comment"># 아이템 추가</span></span><br><span class="line">heapq.heappush(h, (<span class="number">5</span>,<span class="string">'55'</span>))</span><br><span class="line">heapq.heappush(h, (<span class="number">6</span>,<span class="string">'66'</span>))</span><br><span class="line">heapq.heappush(h, (<span class="number">1</span>,<span class="string">'11'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 아이템 삭제</span></span><br><span class="line">heapq.headpop(h)</span><br><span class="line">Out : (<span class="number">1</span>, <span class="string">'11'</span>)</span><br><span class="line">heapq.headpop(h)</span><br><span class="line">Out : (<span class="number">5</span>, <span class="string">'55'</span>)</span><br><span class="line">heapq.headpop(h)</span><br><span class="line">Out : (<span class="number">6</span>, <span class="string">'55'</span>)</span><br></pre></td></tr></table></figure><ul><li>메서드<ul><li>heapq.pushpop(heap, item) : 새 item을 힙에 추가한 후 가장 작은 항목을 제거하고 반환</li><li>heapq.merge(*iterables) : 여러개의 이터러블한 객체를 병합해 하나의 정렬된 이터레이터를 반환</li></ul></li></ul><h3 id="Heap-구현"><a href="#Heap-구현" class="headerlink" title="Heap 구현"></a>Heap 구현</h3><ul><li>파이썬 클래스를 이용해 리스트를 이용한 힙을 구현할 수 있다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Max_Heap 구현</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data=None)</span>:</span></span><br><span class="line">        self.data = data <span class="keyword">or</span> []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.data)//<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            self._max_heap_check(i)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> repr(self.data)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parent</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="string">'this node is root node'</span>)</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (i<span class="number">-2</span>)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (i<span class="number">-1</span>)//<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">left_child</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">right_child</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> i*<span class="number">2</span>+<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_max_heap_check</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        largest = i</span><br><span class="line">        print(<span class="string">"start!"</span>, largest)</span><br><span class="line">        left = self.left_child(i)</span><br><span class="line">        right = self.right_child(i)</span><br><span class="line">        n = len(self.data)</span><br><span class="line">        </span><br><span class="line">        largest = (left &lt; n <span class="keyword">and</span> self.data[left] &gt; self.data[i]) <span class="keyword">and</span> left <span class="keyword">or</span> i</span><br><span class="line">        print(largest)</span><br><span class="line">        largest = (right &lt; n <span class="keyword">and</span> self.data[right] &gt; self.data[largest]) <span class="keyword">and</span> right <span class="keyword">or</span> largest</span><br><span class="line">        print(largest)</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">is</span> <span class="keyword">not</span> largest:</span><br><span class="line">            self.data[i], self.data[largest] = self.data[largest], self.data[i]</span><br><span class="line">            print(<span class="string">"----"</span>, largest)</span><br><span class="line">            self._max_heap_check(largest)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(self)</span>:</span></span><br><span class="line">        max_value = self.data[<span class="number">0</span>]</span><br><span class="line">        self.data[<span class="number">0</span>] = self.data[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">del</span> self.data[<span class="number">-1</span>]</span><br><span class="line">        self._max_heap_check(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max_value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        i = len(self.data)</span><br><span class="line">        self.data.append(item)</span><br><span class="line">        <span class="keyword">while</span> (i != <span class="number">0</span>) <span class="keyword">and</span> item &gt; self.data[self.parent(i)]:</span><br><span class="line">            print(<span class="string">"!!!!!!"</span>, self.data)</span><br><span class="line">            self.data[i] = self.data[self.parent(i)]</span><br><span class="line">            i = self.parent(i)</span><br><span class="line">        self.data[i] = item</span><br></pre></td></tr></table></figure><h2 id="연결-리스트"><a href="#연결-리스트" class="headerlink" title="연결 리스트"></a>연결 리스트</h2><p>연결 리스트는 값과 다음 노드에 대한 포인터를 갖는 노드로 이루어진 리스트이다.</p><p>연결 리스트를 이용해 스택, 큐를 구현할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=None, pointer=None)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.pointer = pointer</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getData</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNext</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.pointer</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setData</span><span class="params">(self, newData)</span>:</span></span><br><span class="line">        self.value = newData</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setNext</span><span class="params">(self, newpointer)</span>:</span></span><br><span class="line">        self.pointer = newpointer</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Node 클래스를 이용한 연결 리스트</span></span><br><span class="line">a = Node(<span class="string">"a"</span>)   </span><br><span class="line">b = Node(<span class="string">"b"</span>, a)</span><br><span class="line">b.getNext().getData()</span><br><span class="line">Out : <span class="string">'a'</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/18/python-datastructure-ch7-2-20200518/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TIL-20200516</title>
      <link>https://hbyyy.github.io/2020/05/16/TIL-20200516/</link>
      <guid>https://hbyyy.github.io/2020/05/16/TIL-20200516/</guid>
      <pubDate>Sat, 16 May 2020 13:14:48 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;1-Github-Action&quot;&gt;&lt;a href=&quot;#1-Github-Action&quot; class=&quot;headerlink&quot; title=&quot;1. Github Action&quot;&gt;&lt;/a&gt;1. Github Action&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;master에 커밋
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="1-Github-Action"><a href="#1-Github-Action" class="headerlink" title="1. Github Action"></a>1. Github Action</h1><ul><li>master에 커밋하거나 pull request 를 보냈을 때 자동으로 테스트를 돌리고 codecov 에 upload 하도록 설정했다</li></ul><h2 id="앞으로-해야할-것"><a href="#앞으로-해야할-것" class="headerlink" title="앞으로 해야할 것"></a>앞으로 해야할 것</h2><ul><li>develop 브랜치와 master 브랜치 각각 Github Action 설정하기<ul><li>develop branch (commit, pull request)<ul><li>기능 하나가 완료되서 develop 브랜치에 합쳐진 것이므로, 이 때는 테스트만 자동으로 하도록 수정하자</li></ul></li><li>master branch (commit, pull request)<ul><li>기능 개발이 다 되었고 버전업을 하는 것이니 자동으로 테스트를 돌리고, <strong>자동으로 배포를 하도록</strong> 설정해 보자</li></ul></li></ul></li></ul>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/16/TIL-20200516/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 자료구조와 알고리즘 - 내장 시퀀스 타입(튜플, 리스트, 바이트, 바이트 배열)</title>
      <link>https://hbyyy.github.io/2020/05/14/python-datastructure-ch2-2-20200514/</link>
      <guid>https://hbyyy.github.io/2020/05/14/python-datastructure-ch2-2-20200514/</guid>
      <pubDate>Thu, 14 May 2020 08:43:08 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;파이썬의 기본 내장 시퀀스 타입에는 문자열, 튜플, 리스트, 바이트, 바이트 배열이 있다&lt;/p&gt;
&lt;p&gt;이번 글에서는 튜플, 리스트, 바이트, 바이트 배열에 대해 정리할 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;튜플&quot;&gt;&lt;a href=&quot;#튜플&quot; class=&quot;headerlink&quot; title=&quot;튜플&quot;&gt;&lt;/a&gt;튜플&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;튜플은 쉼표로 구분된 값으로 이루어진다
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>파이썬의 기본 내장 시퀀스 타입에는 문자열, 튜플, 리스트, 바이트, 바이트 배열이 있다</p><p>이번 글에서는 튜플, 리스트, 바이트, 바이트 배열에 대해 정리할 것이다.</p></blockquote><h2 id="튜플"><a href="#튜플" class="headerlink" title="튜플"></a>튜플</h2><ul><li>튜플은 쉼표로 구분된 값으로 이루어진다<a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">t1 = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">print(t1)</span><br><span class="line">Out : (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">t1[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">Out : <span class="comment"># 튜플은 불변 객체이다.</span></span><br><span class="line">Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 값이 1개인 튜플을 만드려면, 쉼표를 꼭 붙여줘야 한다.</span></span><br><span class="line">t2 = (<span class="number">1</span>)</span><br><span class="line">print(type(t2))</span><br><span class="line">Out : &lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">t2 = (1,) # or t2 = 1,</span><br><span class="line">print(type(t2))</span><br><span class="line">Out : &lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="튜플-매서드"><a href="#튜플-매서드" class="headerlink" title="튜플 매서드"></a>튜플 매서드</h3><h4 id="count-index"><a href="#count-index" class="headerlink" title="count(), index()"></a>count(), index()</h4><ul><li>A.count(x)<ul><li>튜플 A에 담긴 x 항목의 개수를 반환</li></ul></li><li>A.index(x)<ul><li>튜플 A에 있는 첫번째 x 항목의 인덱스를 반환한다.</li></ul></li></ul><h3 id="튜플-언패킹"><a href="#튜플-언패킹" class="headerlink" title="튜플 언패킹"></a>튜플 언패킹</h3><p>파이썬에서 모든 이터러블한 객체는 <strong>시퀀스 언패킹 연산자 (*)</strong> 로 언패킹 할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x, *y = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(x)</span><br><span class="line">Out : <span class="number">1</span></span><br><span class="line">print(y)</span><br><span class="line">Out : [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><h2 id="리스트"><a href="#리스트" class="headerlink" title="리스트"></a>리스트</h2><ul><li>파이썬의 리스트(list) 객체는, <strong>배열</strong>과 유사한 구조이다. </li><li>리스트는 크기를 동적으로 조정할 수 있고, 가변 타입이다.</li></ul><h3 id="리스트-메서드"><a href="#리스트-메서드" class="headerlink" title="리스트 메서드"></a>리스트 메서드</h3><h4 id="append"><a href="#append" class="headerlink" title="append()"></a>append()</h4><ul><li>A.append(x)는 리스트 A 끝에 x 항목을 추가한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">A.append(<span class="number">2</span>)</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#슬라이싱을 이용해도 똑같은 작동을 한다.</span></span><br><span class="line">A[len(A):] = [<span class="number">1</span>]</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="extend"><a href="#extend" class="headerlink" title="extend()"></a>extend()</h4><ul><li>A.extend(iterable)은 리스트 A 끝에 이터러블한 객체의 모든 항목을 추가한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">B = [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">A.extend(B)</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 슬라이싱 이용</span></span><br><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">A[len(A):] = B</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 연산자 이용</span></span><br><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">A += B</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h4><ul><li>A.insert(i, x)는 리스트 A의 i번째 인덱스에 x 항목을 추가한다</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">A.insert(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">print(a)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 슬라이싱 이용</span></span><br><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">A[<span class="number">1</span>:<span class="number">1</span>] = [<span class="number">5</span>]</span><br><span class="line">print(a)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><blockquote><p> insert() 메서트의 시간 복잡도는 O(n)이다. 리스트의 i 인덱스에 새로운 값을 넣는다면, i 인덱스 뒤의 값은 뒤로 한 칸씩 이동시켜야 하기 때문에 O(n)의 시간복잡도를 가진다.</p></blockquote><h4 id="remove-pop"><a href="#remove-pop" class="headerlink" title="remove(), pop()"></a>remove(), pop()</h4><ul><li>A.remove(x)는 리스트 A에서 x값을 가진 항목을 삭제한다. x가 존재하지 않으면 ValueError를 일으키고, x가 여러개 존재하면 맨 앞쪽의 원소를 삭제한다</li><li>A.pop(i) 는 리스트 A의 i번째 인덱스 항목을 제거하고, 그 값을 반환한다. i를 지정해주지 않으면 리스트 맨 뒤의 값을 제거하고 반환한다.</li></ul><h4 id="del"><a href="#del" class="headerlink" title="del"></a>del</h4><ul><li>인덱스를 사용하여 특정한 항목을 삭제한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> A[<span class="number">0</span>]</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 슬라이싱 사용도 가능</span></span><br><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> A[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 변수 자체를 삭제할 수도 있다</span></span><br><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> A</span><br><span class="line">print(A)</span><br><span class="line">Out : </span><br><span class="line">Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">NameError: name <span class="string">'A'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><blockquote><p> 변수를 삭제하고 그 변수가 가리키던 값을 어느 변수도 참조하지 않는다면 파이썬 가비지 컬렉터가 그 데이터를 수집하여 처리해 준다.</p></blockquote><h4 id="index-count"><a href="#index-count" class="headerlink" title="index(), count()"></a>index(), count()</h4><ul><li><p>A.index(x)는 리스트 A에서 x 항목의 인덱스 값을 반환한다. x값이 없다면 ValueError를 반환한다.</p></li><li><p>A.count(x)는 리스트 A에서 x 항목의 갯수를 반환한다.</p></li></ul><h4 id="revers"><a href="#revers" class="headerlink" title="revers()"></a>revers()</h4><ul><li>A.reverse() 메서드는 리스트 A의 항목들을 반전시킨다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">A.reverse()</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 슬라이싱 이용</span></span><br><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(A[::<span class="number">-1</span>])</span><br><span class="line">Out : [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="리스트-컴프리헨션"><a href="#리스트-컴프리헨션" class="headerlink" title="리스트 컴프리헨션"></a>리스트 컴프리헨션</h3><ul><li>파이썬에서 컴프리헨션은 반복되거나 특정 조건을 만족하는 객체를 쉽게 만들어내기 위한 방법이다.</li><li>리스트 뿐만 아니라 셋, 딕셔너리도 컴프리헨션을 사용할 수 있다</li></ul><h5 id="컴프리헨션-형식"><a href="#컴프리헨션-형식" class="headerlink" title="컴프리헨션 형식"></a>컴프리헨션 형식</h5><ul><li>[ 항목 for 항목 in iterable]</li><li>[ 표현식 for 항목 in iterable]</li><li>[ 항목 for 항목 in iterable if 조건]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 표현식 이용</span></span><br><span class="line">A = [i*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 조건문 이용</span></span><br><span class="line">A = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><blockquote><p> 컴프리헨션을 이용해 리스트를 만든다면, 짧은 코드로 값이 들어있는 리스트를 만들 수 있다. 코드가 짧으니 좋아 보이지만, 가독성을 위해서는 여러 줄의 반복문과 조건문으로 구현하는게 나을 수도 있다.</p></blockquote><h2 id="바이트와-바이트-배열"><a href="#바이트와-바이트-배열" class="headerlink" title="바이트와 바이트 배열"></a>바이트와 바이트 배열</h2><ul><li>바이트(bytes)와 바이트 배열(bytearray)는 파이썬에서 바이트를 처리하는데 사용할 수 있는 자료형이다</li><li>bytes는 불변 타입으로 문자열 타입과 유사하고, bytearray는 가변 타입으로 리스트 타입과 유사하다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">bytes1 = bytes(A)</span><br><span class="line">print(bytes1)</span><br><span class="line">Out : <span class="string">b'\x01\x02\x03'</span><span class="comment"># b''는 바이트 문자열이다</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bytes는 불변 객체이다</span></span><br><span class="line">bytes1[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">Out :</span><br><span class="line">Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">TypeError: <span class="string">'bytes'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br><span class="line">bytearray1 = bytearray(A)</span><br><span class="line">print(bytearray1)</span><br><span class="line">Out : bytearray(<span class="string">b'\x01\x02\x03'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#bytearray는 가변 객체이다</span></span><br><span class="line">bytearray1[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">print(bytearray1)</span><br><span class="line">Out : bytearray(<span class="string">b'\x01\x05\x03'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>다음 포스트에서는 셋(set)과 딕셔너리같은 컬렉션 자료구조에 대해 정리할 것이다.</p></blockquote>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/14/python-datastructure-ch2-2-20200514/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 자료구조와 알고리즘 - 내장 시퀀스 타입 (1)</title>
      <link>https://hbyyy.github.io/2020/05/13/python-datastructure-ch2-1-20200513/</link>
      <guid>https://hbyyy.github.io/2020/05/13/python-datastructure-ch2-1-20200513/</guid>
      <pubDate>Wed, 13 May 2020 10:24:25 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;이 챕터에서는 파이썬 내장 시퀀스 타입을 살펴본다.&lt;/p&gt;
&lt;p&gt;시퀀스 타입은 &lt;strong&gt;멤버쉽 연산(in 키워드)&lt;/strong&gt;, &lt;strong&gt;크기 함수(len())&lt;/strong&gt;, &lt;strong&gt;슬라이싱(value[:-1])&lt;/strong&gt;, &lt;strong&gt;반복성&lt;/strong&gt; 을 가진다.&lt;/p&gt;
&lt;p&gt;파이선에서는 &lt;strong&gt;문자열, 튜플, 리스트, 바이트 배열, 바이트&lt;/strong&gt; 5개의 내장 시퀀스 타입이 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;깊은-복사와-슬라이싱-연산&quot;&gt;&lt;a href=&quot;#깊은-복사와-슬라이싱-연산&quot; class=&quot;headerlink&quot; title=&quot;깊은 복사와 슬라이싱 연산&quot;&gt;&lt;/a&gt;깊은 복사와 슬라이싱 연산&lt;/h2&gt;&lt;h3 id=&quot;가변-객체&quot;&gt;&lt;a href=&quot;#가변-객체&quot; class=&quot;headerlink&quot; title=&quot;가변 객체&quot;&gt;&lt;/a&gt;가변 객체&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;파이썬에서 불변 객체로는 &lt;strong&gt;숫자, 튜플, 문자열, 바이트&lt;/strong&gt; 가 있다. 가변 객체로는 &lt;strong&gt;리스트, 바이트 배열&lt;/strong&gt; 등이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;파이썬의 모든 변수는 객체 참조를 한다.  즉, 가변 객체를 복사할 때는 매우 주의해야 한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>이 챕터에서는 파이썬 내장 시퀀스 타입을 살펴본다.</p><p>시퀀스 타입은 <strong>멤버쉽 연산(in 키워드)</strong>, <strong>크기 함수(len())</strong>, <strong>슬라이싱(value[:-1])</strong>, <strong>반복성</strong> 을 가진다.</p><p>파이선에서는 <strong>문자열, 튜플, 리스트, 바이트 배열, 바이트</strong> 5개의 내장 시퀀스 타입이 있다.</p></blockquote><h2 id="깊은-복사와-슬라이싱-연산"><a href="#깊은-복사와-슬라이싱-연산" class="headerlink" title="깊은 복사와 슬라이싱 연산"></a>깊은 복사와 슬라이싱 연산</h2><h3 id="가변-객체"><a href="#가변-객체" class="headerlink" title="가변 객체"></a>가변 객체</h3><ul><li>파이썬에서 불변 객체로는 <strong>숫자, 튜플, 문자열, 바이트</strong> 가 있다. 가변 객체로는 <strong>리스트, 바이트 배열</strong> 등이 있다.</li></ul><p>파이썬의 모든 변수는 객체 참조를 한다.  즉, 가변 객체를 복사할 때는 매우 주의해야 한다.</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">print(a)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(b)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">7</span></span><br><span class="line">print(a)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br><span class="line">print(b)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p> 위의 코드에서,  b 변수가 가리키는 값을 변경했는데, a가 가리키는 리스트의 값도 바뀌는 것을 볼 수 있다. 이는 가변 객체에 할당된 변수의 값은 객체의 위치를 담고 있기 때문이다. 즉 b = a 를 수행하면 b에는 a 가 가리키는 위치가 할당되게 되고, b와 a는 같은 곳을 가리키게 된다.</p><h3 id="깊은-복사"><a href="#깊은-복사" class="headerlink" title="깊은 복사"></a>깊은 복사</h3><ul><li>리스트, 셋, 딕셔너리의 깊은 복사는 다음과 같이 할 수 있다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 리스트의 깊은 복사</span></span><br><span class="line">mylist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">newlist1 = mylist[:]</span><br><span class="line">newlist2 = list(mylist)</span><br><span class="line"><span class="comment"># 셋, 딕셔너리의 복사</span></span><br><span class="line">myset = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">newset = myset.copy()</span><br><span class="line">mydict = &#123;<span class="number">1</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">2</span>&#125;</span><br><span class="line">newdict = mydict.copy()</span><br></pre></td></tr></table></figure><p> 만약 가변 객체에 가변 객체가 들어있는 형태, 예를 들어, </p><p><code>a = [1,[1,2,3]]</code><br>이런 형태라면, 안쪽의 가변 객체까지 완전히 복사해주는 메서드를 사용해야 한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">b = copy.deepcopy(a)</span><br></pre></td></tr></table></figure><h2 id="문자열"><a href="#문자열" class="headerlink" title="문자열"></a>문자열</h2><p> 파이썬에서 모든 문자열은 <strong>유니코드</strong>이다.</p><h3 id="문자열-메서드"><a href="#문자열-메서드" class="headerlink" title="문자열 메서드"></a>문자열 메서드</h3><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><ul><li>리스트에 있는 모든 값을 하나의 단일 문자열로 결합하는 메서드</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="comment"># 앞의 문자열은 리스트의 아이템 간에 추가할 문자열이다.</span></span><br><span class="line">b = <span class="string">""</span>.join(a)</span><br><span class="line">print(b)</span><br><span class="line">Out : <span class="string">"abc"</span></span><br><span class="line">b = <span class="string">"!"</span>.join(a)</span><br><span class="line">print(b)</span><br><span class="line">Out : <span class="string">"a!b!c"</span></span><br></pre></td></tr></table></figure><h4 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h4><ul><li>문자열의 값을 리스트로 분리해서 반환</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"a!b!c"</span></span><br><span class="line">b = a.split(<span class="string">"1"</span>)</span><br><span class="line">print(b)</span><br><span class="line">Out : [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br></pre></td></tr></table></figure><h4 id="index-find"><a href="#index-find" class="headerlink" title="index(), find()"></a>index(), find()</h4><ul><li>A.index(sub, start, end)<ul><li>start - end 범위에서 sub의 인덱스를 찾아 반환</li><li>실패시 <strong>ValueError 예외</strong> 발생</li></ul></li><li>A.find(sub, start, end)<ul><li>start - end 범위에서 sub의 인덱스를 찾아 반환</li><li>실패시 <strong>-1</strong> 반환</li></ul></li></ul><p>다음 포스트에서는 튜플, 리스트, 바이트와 바이트 배열에 대해 정리할 것이다.</p>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/13/python-datastructure-ch2-1-20200513/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 자료구조와 알고리즘 - 추상 데이터 타입 (스택, 큐, 데크)</title>
      <link>https://hbyyy.github.io/2020/05/12/python-datastructure-ch7-1-202005112/</link>
      <guid>https://hbyyy.github.io/2020/05/12/python-datastructure-ch7-1-202005112/</guid>
      <pubDate>Tue, 12 May 2020 13:31:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;CH7-추상-데이터-타입&quot;&gt;&lt;a href=&quot;#CH7-추상-데이터-타입&quot; class=&quot;headerlink&quot; title=&quot;CH7 추상 데이터 타입&quot;&gt;&lt;/a&gt;CH7 추상 데이터 타입&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;추상 데이터 타입(ADT)는 어떠한 자료구조의 클래스에 대한 &lt;strong&gt;수학적 모델&lt;/strong&gt;을 가리킨다&lt;/p&gt;
&lt;p&gt;자료구조는 배열 기반의 연속 방식, 포인터 기반의 연결 방식으로 크게 나누어진다. 파이썬에서 연속적으로 할당된 자료구조는 문자열, 리스트, 튜플, 딕셔너리 등이 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;스택&quot;&gt;&lt;a href=&quot;#스택&quot; class=&quot;headerlink&quot; title=&quot;스택&quot;&gt;&lt;/a&gt;스택&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;스택은 배열의 끝에서만 데이터에 접근할 수 있는 선형 자료구조이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;배열 인덱스 접근이 제한되어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LIFO(후입선출) 구조이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;스택은 깊이 우선 탐색(DFS)에서 유용하게 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="CH7-추상-데이터-타입"><a href="#CH7-추상-데이터-타입" class="headerlink" title="CH7 추상 데이터 타입"></a>CH7 추상 데이터 타입</h2><blockquote><p>추상 데이터 타입(ADT)는 어떠한 자료구조의 클래스에 대한 <strong>수학적 모델</strong>을 가리킨다</p><p>자료구조는 배열 기반의 연속 방식, 포인터 기반의 연결 방식으로 크게 나누어진다. 파이썬에서 연속적으로 할당된 자료구조는 문자열, 리스트, 튜플, 딕셔너리 등이 있다.</p></blockquote><h2 id="스택"><a href="#스택" class="headerlink" title="스택"></a>스택</h2><ul><li><p>스택은 배열의 끝에서만 데이터에 접근할 수 있는 선형 자료구조이다.</p></li><li><p>배열 인덱스 접근이 제한되어야 한다.</p></li><li><p>LIFO(후입선출) 구조이다.</p></li><li><p>스택은 깊이 우선 탐색(DFS)에서 유용하게 사용된다.</p></li></ul><a id="more"></a><p><img src="https://t1.daumcdn.net/cfile/tistory/2750584B56FA9FB23B" alt="img"></p><h3 id="스택의-동작"><a href="#스택의-동작" class="headerlink" title="스택의 동작"></a>스택의 동작</h3><ul><li>가장 중요한 동작으로는 <strong>push</strong> 와 <strong>pop</strong> 이 있다. 각각의 동작은 데이터 삽입, 데이터 추출에 해당한다.</li></ul><h3 id="스택-구현"><a href="#스택-구현" class="headerlink" title="스택 구현"></a>스택 구현</h3><p>파이썬에서는 list 자료형으로 구현할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 데이터 삽입</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.items.append(value)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 데이터 추출</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.items:</span><br><span class="line">            value = self.items[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">del</span>(self.items[<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'Stack is empty!'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 스택의 top을 알려준다</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.items:</span><br><span class="line">            <span class="keyword">return</span> self.items[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'Stack is empty!'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 스택의 size를 알려준다</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> repr(self.items)</span><br></pre></td></tr></table></figure><p>값과 pointer를 가지고 있는 Node class를 생성해서, 연결 리스트처럼 구현할 수도 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="comment"># node는 value와 자기 자신의 바로 아래 있는 Node를 가리키는 pointer로 구성된다</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=None, pointer=None)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.pointer = pointer</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Node를 만들고, head에 추가한 다음 Node의 pointer에 추가하기 전 head에 있던 Node를 연결시켜 준다</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.head = Node(value, self.head)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.head:</span><br><span class="line">            value = self.head.value</span><br><span class="line">            self.head = self.head.pointer</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"Stack is empty!"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 연결되어 있는 Node를 탐색하면서 pointer가 None인 마지막 Node까지 출력</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printStack</span><span class="params">(self)</span>:</span></span><br><span class="line">        top = self.head</span><br><span class="line">        <span class="keyword">if</span> top <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            print(<span class="string">"Stack is empty!"</span>)</span><br><span class="line">        <span class="keyword">while</span> top:</span><br><span class="line">            print(top.value, end=<span class="string">' '</span>)</span><br><span class="line">            top = top.pointer</span><br></pre></td></tr></table></figure><h2 id="큐"><a href="#큐" class="headerlink" title="큐"></a>큐</h2><ul><li>큐는 항목이 들어온 순서대로 접근 가능하다. 즉, FIFO(선입선출) 구조이다.</li></ul><h3 id="큐의-동작"><a href="#큐의-동작" class="headerlink" title="큐의 동작"></a>큐의 동작</h3><ul><li>큐의 동작은 크게 <strong>enqueue</strong>와 <strong>dequeue</strong> 가 있다. 각각 맨 뒤쪽에 데이터 삽입, 맨 앞의 데이터 추출 을 수행하는 동작이다.</li></ul><h3 id="큐-구현"><a href="#큐-구현" class="headerlink" title="큐 구현"></a>큐 구현</h3><ul><li>파이썬 list 자료형과 insert() 메서드를 이용하여 구현할 수 있다</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 데이터 추가, 리스트의 맨 앞쪽에 추가한다</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.items.insert(<span class="number">0</span>, value)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 데이터 추출, 처음에 들어온 데이터부터 추출</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.items:</span><br><span class="line">            value = self.items[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">del</span>(self.items[<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"queue is empty!!"</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> repr(self.items)</span><br></pre></td></tr></table></figure><ul><li>리스트의 insert() 메서드는 O(n)의 시간 복잡도를 가진다. <a href="https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt" target="_blank" rel="noopener">참조</a></li></ul><p>2개의 리스트를 사용하면 더 효율적인 큐 구현이 가능하다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.in_items = []</span><br><span class="line">        self.out_items = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_transfer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.in_items:</span><br><span class="line">            self.out_items.append(self.in_items.pop())</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.in_items.append(value)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.out_items:</span><br><span class="line">            self._transfer()</span><br><span class="line">        <span class="keyword">if</span> self.out_items:</span><br><span class="line">            <span class="keyword">return</span> self.out_items.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"queue in empty!"</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.out_items:</span><br><span class="line">            self._transfer()</span><br><span class="line">        <span class="keyword">if</span> self.out_items:</span><br><span class="line">            <span class="keyword">return</span> repr(self.out_items)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"queue in empty!"</span>)</span><br></pre></td></tr></table></figure><ul><li>스택에서 구현한 것 처럼 Node class 를 구현하여 구현할 수도 있다. 스택과 다른 점은 head와 tail 두가지를 추가해 리스트의 시작과 끝을 가리키게 하면 구현할 수 있다.</li></ul><h2 id="데크"><a href="#데크" class="headerlink" title="데크"></a>데크</h2><ul><li>데크는 큐와 스택의 혼합형이라고 할 수 있다. 양쪽 끝에서 데이터의 추가, 삭제가 가능해야 한다.</li><li>구현은 위의 Queue 구현에서 enqueue_back, dequeue_front 만 추가하면 구현할 수 있다.</li></ul><h3 id="파이썬-Deque-모듈"><a href="#파이썬-Deque-모듈" class="headerlink" title="파이썬 Deque 모듈"></a>파이썬 Deque 모듈</h3><ul><li>파이썬의 collections 패키지에는 구현되어 있는 deque 모듈이 있다. 이것을 사용하면 더 효율적으로 사용할 수 있다.</li></ul>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/12/python-datastructure-ch7-1-202005112/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 자료구조와 알고리즘 - 숫자</title>
      <link>https://hbyyy.github.io/2020/05/12/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98ch1/</link>
      <guid>https://hbyyy.github.io/2020/05/12/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98ch1/</guid>
      <pubDate>Tue, 12 May 2020 09:51:56 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;CH-1-숫자&quot;&gt;&lt;a href=&quot;#CH-1-숫자&quot; class=&quot;headerlink&quot; title=&quot;CH 1 : 숫자&quot;&gt;&lt;/a&gt;CH 1 : 숫자&lt;/h1&gt;&lt;h2 id=&quot;정수&quot;&gt;&lt;a href=&quot;#정수&quot; class=&quot;headerlink&quot; title=&quot;정수&quot;&gt;&lt;/a&gt;정수&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;파이썬에서 정수는 int 로 나타내며, 불변형이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;부동소수점&quot;&gt;&lt;a href=&quot;#부동소수점&quot; class=&quot;headerlink&quot; title=&quot;부동소수점&quot;&gt;&lt;/a&gt;부동소수점&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;부동소수점은 IEEE 754 표준을 따른다. 파이썬에서 부동소수점은 float로 나타내고, 불변형이다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;부동소수점은 이진수로 표현되기 때문에. 함부로 비교하거나 연산하면 안 된다. 예를 들어,&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;In : &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0.3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Out: &lt;span class=&quot;literal&quot;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="CH-1-숫자"><a href="#CH-1-숫자" class="headerlink" title="CH 1 : 숫자"></a>CH 1 : 숫자</h1><h2 id="정수"><a href="#정수" class="headerlink" title="정수"></a>정수</h2><ul><li>파이썬에서 정수는 int 로 나타내며, 불변형이다.</li></ul><h2 id="부동소수점"><a href="#부동소수점" class="headerlink" title="부동소수점"></a>부동소수점</h2><ul><li><p>부동소수점은 IEEE 754 표준을 따른다. 파이썬에서 부동소수점은 float로 나타내고, 불변형이다</p><ul><li><p>부동소수점은 이진수로 표현되기 때문에. 함부로 비교하거나 연산하면 안 된다. 예를 들어,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In : <span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span></span><br><span class="line">Out: <span class="literal">False</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>이런 식으로, 논리적으로 맞는 연산이어도 값은 다르게 나오게 된다. 0.1은 이진수로 0.00110011001100…..으로 표현되기 때문에, 연산 시에 정확한 값이 나오지 않을 것이다.</p></li><li><p>정확한 계산을 위해서는, 파이썬 모듈인 decimal을 사용하면 된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line">  In : Decimal(<span class="string">'0.1'</span>) + Decimal(<span class="string">'0.2'</span>) == Decimal(<span class="string">'0.3'</span>)</span><br><span class="line">Out: <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>이렇게 계산이 정확하게 나오게 된다.</p></li></ul></li></ul><h3 id="정수와-부동소수점-메서드"><a href="#정수와-부동소수점-메서드" class="headerlink" title="정수와 부동소수점 메서드"></a>정수와 부동소수점 메서드</h3><ul><li>파이썬의 나누기 연산자(/)는 항상 부동소수점을 반환한다. 정수 나누기 연산자(//)도 존재한다.</li><li>% 연산자는 나머지를 반환한다.</li><li>divmod(x, y) 매서드<ul><li>x를 y로 나눌 때의 몫과 나머지를 반환한다.</li><li>divmod(x, y)  return : (x//y, x%y)</li></ul></li><li>round(x, n) 매서드<ul><li>n이 음수일 때 : x를 n번째 자리에서 반올림한 값</li><li>n이 양수일 때 : x를 소수점 n번째 이하 자리로 반올림한 값</li></ul></li></ul><h2 id="2진수-8진수-16진수"><a href="#2진수-8진수-16진수" class="headerlink" title="2진수, 8진수, 16진수"></a>2진수, 8진수, 16진수</h2><ul><li>파이썬에는 2진수, 8진수, 16진수를 반환하는 함수가 존재한다.<ul><li>2진수 : bin(string)</li><li>8진수 : oct(string)</li><li>16진수 : hex(string)</li></ul></li></ul>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/12/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98ch1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>자료구조 - 해시 테이블</title>
      <link>https://hbyyy.github.io/2020/02/26/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94/</link>
      <guid>https://hbyyy.github.io/2020/02/26/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94/</guid>
      <pubDate>Tue, 25 Feb 2020 18:29:24 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;해쉬-테이블&quot;&gt;&lt;a href=&quot;#해쉬-테이블&quot; class=&quot;headerlink&quot; title=&quot;해쉬 테이블&quot;&gt;&lt;/a&gt;해쉬 테이블&lt;/h2&gt;&lt;h3 id=&quot;용어&quot;&gt;&lt;a href=&quot;#용어&quot; class=&quot;headerlink&quot; title=&quot;용어&quot;&gt;&lt;/a&gt;용어&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;해쉬(hash) : 임의 값을 고정 길이로 변환하는 것&lt;/li&gt;
&lt;li&gt;해쉬 테이블(hash table): 키 값의 연산에 의해 직접 접근이 가능한 테이터 구조&lt;/li&gt;
&lt;li&gt;해싱 함수(hashing function) : key에 대해 산술 연산을 이용해 데이터 위치를 찾을 수 있는 함수&lt;/li&gt;
&lt;li&gt;해쉬 값(hash value) 또는 해쉬 주소(hash address) : key를 해싱 함수로 연산한 값, 이 값의 위치에 해당 key에 대한 값을 저장한다&lt;/li&gt;
&lt;li&gt;슬롯(slot) : 한 개의 데이터를 저장할 수 있는 공간
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="해쉬-테이블"><a href="#해쉬-테이블" class="headerlink" title="해쉬 테이블"></a>해쉬 테이블</h2><h3 id="용어"><a href="#용어" class="headerlink" title="용어"></a>용어</h3><ul><li>해쉬(hash) : 임의 값을 고정 길이로 변환하는 것</li><li>해쉬 테이블(hash table): 키 값의 연산에 의해 직접 접근이 가능한 테이터 구조</li><li>해싱 함수(hashing function) : key에 대해 산술 연산을 이용해 데이터 위치를 찾을 수 있는 함수</li><li>해쉬 값(hash value) 또는 해쉬 주소(hash address) : key를 해싱 함수로 연산한 값, 이 값의 위치에 해당 key에 대한 값을 저장한다</li><li>슬롯(slot) : 한 개의 데이터를 저장할 수 있는 공간<a id="more"></a></li></ul><h3 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h3><h4 id="해쉬-테이블-만들기"><a href="#해쉬-테이블-만들기" class="headerlink" title="해쉬 테이블 만들기"></a>해쉬 테이블 만들기</h4><ol><li>간단한 해시 함수 (Division 이용)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hash_func</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> key % <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ord() -&gt; 문자의 아스키 코드 리턴</span></span><br><span class="line"><span class="comment"># 해쉬 테이블에 데이터를 저장</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">storage_data</span><span class="params">(data, value)</span>:</span></span><br><span class="line">    key = ord(data[<span class="number">0</span>])</span><br><span class="line">    hash_address = hash_func(key)</span><br><span class="line">    hash_table[hash_address] = value</span><br><span class="line"></span><br><span class="line"><span class="comment">#해쉬 테이블에서 해당 데이터의 값을 가져온다</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(data)</span>:</span></span><br><span class="line">    key = ord(data[<span class="number">0</span>])</span><br><span class="line">    hash_address = hash_func(key)</span><br><span class="line">    <span class="keyword">return</span> hash_table[hash_address]</span><br><span class="line">    </span><br><span class="line">data1 = <span class="string">'Andy'</span></span><br><span class="line">data2 = <span class="string">'Dave'</span></span><br><span class="line">data3 = <span class="string">'Trump'</span></span><br><span class="line"></span><br><span class="line">storage_data(<span class="string">'Andy'</span>, <span class="string">'01055553333'</span>)</span><br><span class="line">storage_data(<span class="string">'Dave'</span>, <span class="string">'01012341234'</span>)</span><br><span class="line">storage_data(<span class="string">'Trump'</span>, <span class="string">'01009876543'</span>)</span><br><span class="line"></span><br><span class="line">get_data(<span class="string">'Andy'</span>)</span><br><span class="line"><span class="comment"># '01055553333'</span></span><br></pre></td></tr></table></figure><h3 id="해쉬-테이블의-장단점"><a href="#해쉬-테이블의-장단점" class="headerlink" title="해쉬 테이블의 장단점"></a>해쉬 테이블의 장단점</h3><ul><li>장점<ul><li>데이터 저장/읽기 속도가 빠르다</li><li>데이터의 중복 확인이 쉽다</li></ul></li><li>단점<ul><li>저장 공간이 많이 필요하다.</li><li>키가 충돌할 경우 처리할 별도의 자료구조가 필요하다<ul><li>공간을 늘리는 것으로 어느정도 해결이 가능</li></ul></li></ul></li></ul><h3 id="충돌-해결-알고리즘"><a href="#충돌-해결-알고리즘" class="headerlink" title="충돌 해결 알고리즘"></a>충돌 해결 알고리즘</h3><blockquote><p>다른 data 가 값은 해쉬 값을 가지는 것을 충돌이라 한다.</p></blockquote><h4 id="Chaining-기법"><a href="#Chaining-기법" class="headerlink" title="Chaining 기법"></a>Chaining 기법</h4><ul><li>해쉬 테이블 외의 저장공간을 이용<ul><li><strong>개방 해싱(Open hashing)</strong> 기법</li></ul></li><li>충돌이 일어나면, 링크드 리스트로 데이터를 뒤에 연결함</li></ul><h4 id="Linear-Probing-기법"><a href="#Linear-Probing-기법" class="headerlink" title="Linear Probing 기법"></a>Linear Probing 기법</h4><ul><li>해쉬 테이블 내의 저장공간을 이용<ul><li><strong>폐쇄 해슁(Close hashing)</strong> 기법</li></ul></li><li>충돌이 일어나면, 해당 hash address의 다음 address부터 맨 처음 나오는 빈 공간에 저장</li></ul><h4 id="Chaining-기법-예시"><a href="#Chaining-기법-예시" class="headerlink" title="Chaining 기법 예시"></a>Chaining 기법 예시</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_key</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hash(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hash_func</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> key % <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_data</span><span class="params">(data, value)</span>:</span></span><br><span class="line">    index_key = get_key(data)</span><br><span class="line">    hash_address = hash_func(index_key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hash_table2[hash_address]:</span><br><span class="line">        hash_table2[hash_address].append([index_key, value])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> hash_table2[hash_address]:</span><br><span class="line">            <span class="keyword">if</span> index[<span class="number">0</span>] == index_key:</span><br><span class="line">                index[<span class="number">1</span>] = value</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        hash_table2[hash_address].append([index_key, value])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">(data)</span>:</span></span><br><span class="line">    index_key = get_key(data)</span><br><span class="line">    hash_address = hash_func(index_key)</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> hash_table2[hash_address]:</span><br><span class="line">        <span class="keyword">if</span> index[<span class="number">0</span>] == index_key:</span><br><span class="line">            print(index[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> index[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">'데이터가 없습니다'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/02/26/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
