<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>hbyyy&#39;s blog</title>
    <link>https://hbyyy.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 18 May 2020 10:54:43 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>파이썬 자료구조와 알고리즘 - 추상 데이터 타입(우선순위 큐, 연결 리스트)</title>
      <link>https://hbyyy.github.io/2020/05/18/python-datastructure-ch7-2-20200518/</link>
      <guid>https://hbyyy.github.io/2020/05/18/python-datastructure-ch7-2-20200518/</guid>
      <pubDate>Mon, 18 May 2020 10:52:47 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;이번 포스트에서는 우선순위 큐, 연결 리스트에 대해 정리할 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;우선순위-큐와-힙&quot;&gt;&lt;a href=&quot;#우선순위-큐와-힙&quot; class=&quot;headerlink&quot; title=&quot;우선순위 큐와 힙&quot;&gt;&lt;/a&gt;우선순위 큐와 힙&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;우선순위 큐는 항목마다 우선순위가 있고, 우선순위가 같으면 큐의 순서를 따른다&lt;/li&gt;
&lt;li&gt;우선순위 큐는 주로 힙을 사용해 구현한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;힙&quot;&gt;&lt;a href=&quot;#힙&quot; class=&quot;headerlink&quot; title=&quot;힙&quot;&gt;&lt;/a&gt;힙&lt;/h3&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>이번 포스트에서는 우선순위 큐, 연결 리스트에 대해 정리할 것이다.</p></blockquote><h2 id="우선순위-큐와-힙"><a href="#우선순위-큐와-힙" class="headerlink" title="우선순위 큐와 힙"></a>우선순위 큐와 힙</h2><ul><li>우선순위 큐는 항목마다 우선순위가 있고, 우선순위가 같으면 큐의 순서를 따른다</li><li>우선순위 큐는 주로 힙을 사용해 구현한다.</li></ul><h3 id="힙"><a href="#힙" class="headerlink" title="힙"></a>힙</h3><a id="more"></a><p><img src="https://gmlwjd9405.github.io/images/data-structure-heap/types-of-heap.png" alt="img"></p><ul><li>힙은 각 노드가 하위 노드보다 작은 or 큰 이진 트리이다.</li></ul><p>리스트에서 가장 작은(또는 큰) 값에 반복적으로 접근해햐 한다면 힙이 유용하다.</p><p>최대 힙, 최소 힙에서 각각 최댓값, 최솟값은 루트 노드에 위치하고 있으니, 이 요소를 처리하는 시간복잡도는 O(1)이다. </p><p>조회, 추가, 수정을 처리하는 시간복잡도는 O(logn)이다. </p><h3 id="heapq-모듈"><a href="#heapq-모듈" class="headerlink" title="heapq 모듈"></a>heapq 모듈</h3><p>파이썬에는 힙 자료구조를 사용할 수 있는 heapq 모듈이 존재한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">h = []</span><br><span class="line"><span class="comment"># 아이템 추가</span></span><br><span class="line">heapq.heappush(h, (<span class="number">5</span>,<span class="string">'55'</span>))</span><br><span class="line">heapq.heappush(h, (<span class="number">6</span>,<span class="string">'66'</span>))</span><br><span class="line">heapq.heappush(h, (<span class="number">1</span>,<span class="string">'11'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 아이템 삭제</span></span><br><span class="line">heapq.headpop(h)</span><br><span class="line">Out : (<span class="number">1</span>, <span class="string">'11'</span>)</span><br><span class="line">heapq.headpop(h)</span><br><span class="line">Out : (<span class="number">5</span>, <span class="string">'55'</span>)</span><br><span class="line">heapq.headpop(h)</span><br><span class="line">Out : (<span class="number">6</span>, <span class="string">'55'</span>)</span><br></pre></td></tr></table></figure><ul><li>메서드<ul><li>heapq.pushpop(heap, item) : 새 item을 힙에 추가한 후 가장 작은 항목을 제거하고 반환</li><li>heapq.merge(*iterables) : 여러개의 이터러블한 객체를 병합해 하나의 정렬된 이터레이터를 반환</li></ul></li></ul><h3 id="Heap-구현"><a href="#Heap-구현" class="headerlink" title="Heap 구현"></a>Heap 구현</h3><ul><li>파이썬 클래스를 이용해 리스트를 이용한 힙을 구현할 수 있다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Max_Heap 구현</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data=None)</span>:</span></span><br><span class="line">        self.data = data <span class="keyword">or</span> []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.data)//<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            self._max_heap_check(i)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> repr(self.data)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parent</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="string">'this node is root node'</span>)</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (i<span class="number">-2</span>)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (i<span class="number">-1</span>)//<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">left_child</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">right_child</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> i*<span class="number">2</span>+<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_max_heap_check</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        largest = i</span><br><span class="line">        print(<span class="string">"start!"</span>, largest)</span><br><span class="line">        left = self.left_child(i)</span><br><span class="line">        right = self.right_child(i)</span><br><span class="line">        n = len(self.data)</span><br><span class="line">        </span><br><span class="line">        largest = (left &lt; n <span class="keyword">and</span> self.data[left] &gt; self.data[i]) <span class="keyword">and</span> left <span class="keyword">or</span> i</span><br><span class="line">        print(largest)</span><br><span class="line">        largest = (right &lt; n <span class="keyword">and</span> self.data[right] &gt; self.data[largest]) <span class="keyword">and</span> right <span class="keyword">or</span> largest</span><br><span class="line">        print(largest)</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">is</span> <span class="keyword">not</span> largest:</span><br><span class="line">            self.data[i], self.data[largest] = self.data[largest], self.data[i]</span><br><span class="line">            print(<span class="string">"----"</span>, largest)</span><br><span class="line">            self._max_heap_check(largest)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(self)</span>:</span></span><br><span class="line">        max_value = self.data[<span class="number">0</span>]</span><br><span class="line">        self.data[<span class="number">0</span>] = self.data[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">del</span> self.data[<span class="number">-1</span>]</span><br><span class="line">        self._max_heap_check(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max_value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        i = len(self.data)</span><br><span class="line">        self.data.append(item)</span><br><span class="line">        <span class="keyword">while</span> (i != <span class="number">0</span>) <span class="keyword">and</span> item &gt; self.data[self.parent(i)]:</span><br><span class="line">            print(<span class="string">"!!!!!!"</span>, self.data)</span><br><span class="line">            self.data[i] = self.data[self.parent(i)]</span><br><span class="line">            i = self.parent(i)</span><br><span class="line">        self.data[i] = item</span><br></pre></td></tr></table></figure><h2 id="연결-리스트"><a href="#연결-리스트" class="headerlink" title="연결 리스트"></a>연결 리스트</h2><p>연결 리스트는 값과 다음 노드에 대한 포인터를 갖는 노드로 이루어진 리스트이다.</p><p>연결 리스트를 이용해 스택, 큐를 구현할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=None, pointer=None)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.pointer = pointer</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getData</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNext</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.pointer</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setData</span><span class="params">(self, newData)</span>:</span></span><br><span class="line">        self.value = newData</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setNext</span><span class="params">(self, newpointer)</span>:</span></span><br><span class="line">        self.pointer = newpointer</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Node 클래스를 이용한 연결 리스트</span></span><br><span class="line">a = Node(<span class="string">"a"</span>)   </span><br><span class="line">b = Node(<span class="string">"b"</span>, a)</span><br><span class="line">b.getNext().getData()</span><br><span class="line">Out : <span class="string">'a'</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/18/python-datastructure-ch7-2-20200518/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 자료구조와 알고리즘 - 내장 시퀀스 타입(튜플, 리스트, 바이트, 바이트 배열)</title>
      <link>https://hbyyy.github.io/2020/05/14/python-datastructure-ch2-2-20200514/</link>
      <guid>https://hbyyy.github.io/2020/05/14/python-datastructure-ch2-2-20200514/</guid>
      <pubDate>Thu, 14 May 2020 08:43:08 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;파이썬의 기본 내장 시퀀스 타입에는 문자열, 튜플, 리스트, 바이트, 바이트 배열이 있다&lt;/p&gt;
&lt;p&gt;이번 글에서는 튜플, 리스트, 바이트, 바이트 배열에 대해 정리할 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;튜플&quot;&gt;&lt;a href=&quot;#튜플&quot; class=&quot;headerlink&quot; title=&quot;튜플&quot;&gt;&lt;/a&gt;튜플&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;튜플은 쉼표로 구분된 값으로 이루어진다
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>파이썬의 기본 내장 시퀀스 타입에는 문자열, 튜플, 리스트, 바이트, 바이트 배열이 있다</p><p>이번 글에서는 튜플, 리스트, 바이트, 바이트 배열에 대해 정리할 것이다.</p></blockquote><h2 id="튜플"><a href="#튜플" class="headerlink" title="튜플"></a>튜플</h2><ul><li>튜플은 쉼표로 구분된 값으로 이루어진다<a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">t1 = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">print(t1)</span><br><span class="line">Out : (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">t1[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">Out : <span class="comment"># 튜플은 불변 객체이다.</span></span><br><span class="line">Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 값이 1개인 튜플을 만드려면, 쉼표를 꼭 붙여줘야 한다.</span></span><br><span class="line">t2 = (<span class="number">1</span>)</span><br><span class="line">print(type(t2))</span><br><span class="line">Out : &lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">t2 = (1,) # or t2 = 1,</span><br><span class="line">print(type(t2))</span><br><span class="line">Out : &lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="튜플-매서드"><a href="#튜플-매서드" class="headerlink" title="튜플 매서드"></a>튜플 매서드</h3><h4 id="count-index"><a href="#count-index" class="headerlink" title="count(), index()"></a>count(), index()</h4><ul><li>A.count(x)<ul><li>튜플 A에 담긴 x 항목의 개수를 반환</li></ul></li><li>A.index(x)<ul><li>튜플 A에 있는 첫번째 x 항목의 인덱스를 반환한다.</li></ul></li></ul><h3 id="튜플-언패킹"><a href="#튜플-언패킹" class="headerlink" title="튜플 언패킹"></a>튜플 언패킹</h3><p>파이썬에서 모든 이터러블한 객체는 <strong>시퀀스 언패킹 연산자 (*)</strong> 로 언패킹 할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x, *y = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(x)</span><br><span class="line">Out : <span class="number">1</span></span><br><span class="line">print(y)</span><br><span class="line">Out : [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><h2 id="리스트"><a href="#리스트" class="headerlink" title="리스트"></a>리스트</h2><ul><li>파이썬의 리스트(list) 객체는, <strong>배열</strong>과 유사한 구조이다. </li><li>리스트는 크기를 동적으로 조정할 수 있고, 가변 타입이다.</li></ul><h3 id="리스트-메서드"><a href="#리스트-메서드" class="headerlink" title="리스트 메서드"></a>리스트 메서드</h3><h4 id="append"><a href="#append" class="headerlink" title="append()"></a>append()</h4><ul><li>A.append(x)는 리스트 A 끝에 x 항목을 추가한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">A.append(<span class="number">2</span>)</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#슬라이싱을 이용해도 똑같은 작동을 한다.</span></span><br><span class="line">A[len(A):] = [<span class="number">1</span>]</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="extend"><a href="#extend" class="headerlink" title="extend()"></a>extend()</h4><ul><li>A.extend(iterable)은 리스트 A 끝에 이터러블한 객체의 모든 항목을 추가한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">B = [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">A.extend(B)</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 슬라이싱 이용</span></span><br><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">A[len(A):] = B</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 연산자 이용</span></span><br><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">A += B</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h4><ul><li>A.insert(i, x)는 리스트 A의 i번째 인덱스에 x 항목을 추가한다</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">A.insert(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">print(a)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 슬라이싱 이용</span></span><br><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">A[<span class="number">1</span>:<span class="number">1</span>] = [<span class="number">5</span>]</span><br><span class="line">print(a)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><blockquote><p> insert() 메서트의 시간 복잡도는 O(n)이다. 리스트의 i 인덱스에 새로운 값을 넣는다면, i 인덱스 뒤의 값은 뒤로 한 칸씩 이동시켜야 하기 때문에 O(n)의 시간복잡도를 가진다.</p></blockquote><h4 id="remove-pop"><a href="#remove-pop" class="headerlink" title="remove(), pop()"></a>remove(), pop()</h4><ul><li>A.remove(x)는 리스트 A에서 x값을 가진 항목을 삭제한다. x가 존재하지 않으면 ValueError를 일으키고, x가 여러개 존재하면 맨 앞쪽의 원소를 삭제한다</li><li>A.pop(i) 는 리스트 A의 i번째 인덱스 항목을 제거하고, 그 값을 반환한다. i를 지정해주지 않으면 리스트 맨 뒤의 값을 제거하고 반환한다.</li></ul><h4 id="del"><a href="#del" class="headerlink" title="del"></a>del</h4><ul><li>인덱스를 사용하여 특정한 항목을 삭제한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> A[<span class="number">0</span>]</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 슬라이싱 사용도 가능</span></span><br><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> A[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 변수 자체를 삭제할 수도 있다</span></span><br><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> A</span><br><span class="line">print(A)</span><br><span class="line">Out : </span><br><span class="line">Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">NameError: name <span class="string">'A'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><blockquote><p> 변수를 삭제하고 그 변수가 가리키던 값을 어느 변수도 참조하지 않는다면 파이썬 가비지 컬렉터가 그 데이터를 수집하여 처리해 준다.</p></blockquote><h4 id="index-count"><a href="#index-count" class="headerlink" title="index(), count()"></a>index(), count()</h4><ul><li><p>A.index(x)는 리스트 A에서 x 항목의 인덱스 값을 반환한다. x값이 없다면 ValueError를 반환한다.</p></li><li><p>A.count(x)는 리스트 A에서 x 항목의 갯수를 반환한다.</p></li></ul><h4 id="revers"><a href="#revers" class="headerlink" title="revers()"></a>revers()</h4><ul><li>A.reverse() 메서드는 리스트 A의 항목들을 반전시킨다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">A.reverse()</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 슬라이싱 이용</span></span><br><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(A[::<span class="number">-1</span>])</span><br><span class="line">Out : [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="리스트-컴프리헨션"><a href="#리스트-컴프리헨션" class="headerlink" title="리스트 컴프리헨션"></a>리스트 컴프리헨션</h3><ul><li>파이썬에서 컴프리헨션은 반복되거나 특정 조건을 만족하는 객체를 쉽게 만들어내기 위한 방법이다.</li><li>리스트 뿐만 아니라 셋, 딕셔너리도 컴프리헨션을 사용할 수 있다</li></ul><h5 id="컴프리헨션-형식"><a href="#컴프리헨션-형식" class="headerlink" title="컴프리헨션 형식"></a>컴프리헨션 형식</h5><ul><li>[ 항목 for 항목 in iterable]</li><li>[ 표현식 for 항목 in iterable]</li><li>[ 항목 for 항목 in iterable if 조건]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 표현식 이용</span></span><br><span class="line">A = [i*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 조건문 이용</span></span><br><span class="line">A = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">print(A)</span><br><span class="line">Out : [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><blockquote><p> 컴프리헨션을 이용해 리스트를 만든다면, 짧은 코드로 값이 들어있는 리스트를 만들 수 있다. 코드가 짧으니 좋아 보이지만, 가독성을 위해서는 여러 줄의 반복문과 조건문으로 구현하는게 나을 수도 있다.</p></blockquote><h2 id="바이트와-바이트-배열"><a href="#바이트와-바이트-배열" class="headerlink" title="바이트와 바이트 배열"></a>바이트와 바이트 배열</h2><ul><li>바이트(bytes)와 바이트 배열(bytearray)는 파이썬에서 바이트를 처리하는데 사용할 수 있는 자료형이다</li><li>bytes는 불변 타입으로 문자열 타입과 유사하고, bytearray는 가변 타입으로 리스트 타입과 유사하다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">bytes1 = bytes(A)</span><br><span class="line">print(bytes1)</span><br><span class="line">Out : <span class="string">b'\x01\x02\x03'</span><span class="comment"># b''는 바이트 문자열이다</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bytes는 불변 객체이다</span></span><br><span class="line">bytes1[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">Out :</span><br><span class="line">Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">TypeError: <span class="string">'bytes'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br><span class="line">bytearray1 = bytearray(A)</span><br><span class="line">print(bytearray1)</span><br><span class="line">Out : bytearray(<span class="string">b'\x01\x02\x03'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#bytearray는 가변 객체이다</span></span><br><span class="line">bytearray1[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">print(bytearray1)</span><br><span class="line">Out : bytearray(<span class="string">b'\x01\x05\x03'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>다음 포스트에서는 셋(set)과 딕셔너리같은 컬렉션 자료구조에 대해 정리할 것이다.</p></blockquote>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/14/python-datastructure-ch2-2-20200514/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 자료구조와 알고리즘 - 내장 시퀀스 타입 (1)</title>
      <link>https://hbyyy.github.io/2020/05/13/python-datastructure-ch2-1-20200513/</link>
      <guid>https://hbyyy.github.io/2020/05/13/python-datastructure-ch2-1-20200513/</guid>
      <pubDate>Wed, 13 May 2020 10:24:25 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;이 챕터에서는 파이썬 내장 시퀀스 타입을 살펴본다.&lt;/p&gt;
&lt;p&gt;시퀀스 타입은 &lt;strong&gt;멤버쉽 연산(in 키워드)&lt;/strong&gt;, &lt;strong&gt;크기 함수(len())&lt;/strong&gt;, &lt;strong&gt;슬라이싱(value[:-1])&lt;/strong&gt;, &lt;strong&gt;반복성&lt;/strong&gt; 을 가진다.&lt;/p&gt;
&lt;p&gt;파이선에서는 &lt;strong&gt;문자열, 튜플, 리스트, 바이트 배열, 바이트&lt;/strong&gt; 5개의 내장 시퀀스 타입이 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;깊은-복사와-슬라이싱-연산&quot;&gt;&lt;a href=&quot;#깊은-복사와-슬라이싱-연산&quot; class=&quot;headerlink&quot; title=&quot;깊은 복사와 슬라이싱 연산&quot;&gt;&lt;/a&gt;깊은 복사와 슬라이싱 연산&lt;/h2&gt;&lt;h3 id=&quot;가변-객체&quot;&gt;&lt;a href=&quot;#가변-객체&quot; class=&quot;headerlink&quot; title=&quot;가변 객체&quot;&gt;&lt;/a&gt;가변 객체&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;파이썬에서 불변 객체로는 &lt;strong&gt;숫자, 튜플, 문자열, 바이트&lt;/strong&gt; 가 있다. 가변 객체로는 &lt;strong&gt;리스트, 바이트 배열&lt;/strong&gt; 등이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;파이썬의 모든 변수는 객체 참조를 한다.  즉, 가변 객체를 복사할 때는 매우 주의해야 한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>이 챕터에서는 파이썬 내장 시퀀스 타입을 살펴본다.</p><p>시퀀스 타입은 <strong>멤버쉽 연산(in 키워드)</strong>, <strong>크기 함수(len())</strong>, <strong>슬라이싱(value[:-1])</strong>, <strong>반복성</strong> 을 가진다.</p><p>파이선에서는 <strong>문자열, 튜플, 리스트, 바이트 배열, 바이트</strong> 5개의 내장 시퀀스 타입이 있다.</p></blockquote><h2 id="깊은-복사와-슬라이싱-연산"><a href="#깊은-복사와-슬라이싱-연산" class="headerlink" title="깊은 복사와 슬라이싱 연산"></a>깊은 복사와 슬라이싱 연산</h2><h3 id="가변-객체"><a href="#가변-객체" class="headerlink" title="가변 객체"></a>가변 객체</h3><ul><li>파이썬에서 불변 객체로는 <strong>숫자, 튜플, 문자열, 바이트</strong> 가 있다. 가변 객체로는 <strong>리스트, 바이트 배열</strong> 등이 있다.</li></ul><p>파이썬의 모든 변수는 객체 참조를 한다.  즉, 가변 객체를 복사할 때는 매우 주의해야 한다.</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">print(a)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(b)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">7</span></span><br><span class="line">print(a)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br><span class="line">print(b)</span><br><span class="line">Out : [<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p> 위의 코드에서,  b 변수가 가리키는 값을 변경했는데, a가 가리키는 리스트의 값도 바뀌는 것을 볼 수 있다. 이는 가변 객체에 할당된 변수의 값은 객체의 위치를 담고 있기 때문이다. 즉 b = a 를 수행하면 b에는 a 가 가리키는 위치가 할당되게 되고, b와 a는 같은 곳을 가리키게 된다.</p><h3 id="깊은-복사"><a href="#깊은-복사" class="headerlink" title="깊은 복사"></a>깊은 복사</h3><ul><li>리스트, 셋, 딕셔너리의 깊은 복사는 다음과 같이 할 수 있다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 리스트의 깊은 복사</span></span><br><span class="line">mylist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">newlist1 = mylist[:]</span><br><span class="line">newlist2 = list(mylist)</span><br><span class="line"><span class="comment"># 셋, 딕셔너리의 복사</span></span><br><span class="line">myset = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">newset = myset.copy()</span><br><span class="line">mydict = &#123;<span class="number">1</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">2</span>&#125;</span><br><span class="line">newdict = mydict.copy()</span><br></pre></td></tr></table></figure><p> 만약 가변 객체에 가변 객체가 들어있는 형태, 예를 들어, </p><p><code>a = [1,[1,2,3]]</code><br>이런 형태라면, 안쪽의 가변 객체까지 완전히 복사해주는 메서드를 사용해야 한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">b = copy.deepcopy(a)</span><br></pre></td></tr></table></figure><h2 id="문자열"><a href="#문자열" class="headerlink" title="문자열"></a>문자열</h2><p> 파이썬에서 모든 문자열은 <strong>유니코드</strong>이다.</p><h3 id="문자열-메서드"><a href="#문자열-메서드" class="headerlink" title="문자열 메서드"></a>문자열 메서드</h3><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><ul><li>리스트에 있는 모든 값을 하나의 단일 문자열로 결합하는 메서드</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="comment"># 앞의 문자열은 리스트의 아이템 간에 추가할 문자열이다.</span></span><br><span class="line">b = <span class="string">""</span>.join(a)</span><br><span class="line">print(b)</span><br><span class="line">Out : <span class="string">"abc"</span></span><br><span class="line">b = <span class="string">"!"</span>.join(a)</span><br><span class="line">print(b)</span><br><span class="line">Out : <span class="string">"a!b!c"</span></span><br></pre></td></tr></table></figure><h4 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h4><ul><li>문자열의 값을 리스트로 분리해서 반환</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"a!b!c"</span></span><br><span class="line">b = a.split(<span class="string">"1"</span>)</span><br><span class="line">print(b)</span><br><span class="line">Out : [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br></pre></td></tr></table></figure><h4 id="index-find"><a href="#index-find" class="headerlink" title="index(), find()"></a>index(), find()</h4><ul><li>A.index(sub, start, end)<ul><li>start - end 범위에서 sub의 인덱스를 찾아 반환</li><li>실패시 <strong>ValueError 예외</strong> 발생</li></ul></li><li>A.find(sub, start, end)<ul><li>start - end 범위에서 sub의 인덱스를 찾아 반환</li><li>실패시 <strong>-1</strong> 반환</li></ul></li></ul><p>다음 포스트에서는 튜플, 리스트, 바이트와 바이트 배열에 대해 정리할 것이다.</p>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/13/python-datastructure-ch2-1-20200513/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 자료구조와 알고리즘 - 추상 데이터 타입 (스택, 큐, 데크)</title>
      <link>https://hbyyy.github.io/2020/05/12/python-datastructure-algo-ch7-1/</link>
      <guid>https://hbyyy.github.io/2020/05/12/python-datastructure-algo-ch7-1/</guid>
      <pubDate>Tue, 12 May 2020 13:31:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;CH7-추상-데이터-타입&quot;&gt;&lt;a href=&quot;#CH7-추상-데이터-타입&quot; class=&quot;headerlink&quot; title=&quot;CH7 추상 데이터 타입&quot;&gt;&lt;/a&gt;CH7 추상 데이터 타입&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;추상 데이터 타입(ADT)는 어떠한 자료구조의 클래스에 대한 &lt;strong&gt;수학적 모델&lt;/strong&gt;을 가리킨다&lt;/p&gt;
&lt;p&gt;자료구조는 배열 기반의 연속 방식, 포인터 기반의 연결 방식으로 크게 나누어진다. 파이썬에서 연속적으로 할당된 자료구조는 문자열, 리스트, 튜플, 딕셔너리 등이 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;스택&quot;&gt;&lt;a href=&quot;#스택&quot; class=&quot;headerlink&quot; title=&quot;스택&quot;&gt;&lt;/a&gt;스택&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;스택은 배열의 끝에서만 데이터에 접근할 수 있는 선형 자료구조이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;배열 인덱스 접근이 제한되어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LIFO(후입선출) 구조이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;스택은 깊이 우선 탐색(DFS)에서 유용하게 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="CH7-추상-데이터-타입"><a href="#CH7-추상-데이터-타입" class="headerlink" title="CH7 추상 데이터 타입"></a>CH7 추상 데이터 타입</h2><blockquote><p>추상 데이터 타입(ADT)는 어떠한 자료구조의 클래스에 대한 <strong>수학적 모델</strong>을 가리킨다</p><p>자료구조는 배열 기반의 연속 방식, 포인터 기반의 연결 방식으로 크게 나누어진다. 파이썬에서 연속적으로 할당된 자료구조는 문자열, 리스트, 튜플, 딕셔너리 등이 있다.</p></blockquote><h2 id="스택"><a href="#스택" class="headerlink" title="스택"></a>스택</h2><ul><li><p>스택은 배열의 끝에서만 데이터에 접근할 수 있는 선형 자료구조이다.</p></li><li><p>배열 인덱스 접근이 제한되어야 한다.</p></li><li><p>LIFO(후입선출) 구조이다.</p></li><li><p>스택은 깊이 우선 탐색(DFS)에서 유용하게 사용된다.</p></li></ul><a id="more"></a><p><img src="https://t1.daumcdn.net/cfile/tistory/2750584B56FA9FB23B" alt="img"></p><h3 id="스택의-동작"><a href="#스택의-동작" class="headerlink" title="스택의 동작"></a>스택의 동작</h3><ul><li>가장 중요한 동작으로는 <strong>push</strong> 와 <strong>pop</strong> 이 있다. 각각의 동작은 데이터 삽입, 데이터 추출에 해당한다.</li></ul><h3 id="스택-구현"><a href="#스택-구현" class="headerlink" title="스택 구현"></a>스택 구현</h3><p>파이썬에서는 list 자료형으로 구현할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 데이터 삽입</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.items.append(value)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 데이터 추출</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.items:</span><br><span class="line">            value = self.items[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">del</span>(self.items[<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'Stack is empty!'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 스택의 top을 알려준다</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.items:</span><br><span class="line">            <span class="keyword">return</span> self.items[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'Stack is empty!'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 스택의 size를 알려준다</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> repr(self.items)</span><br></pre></td></tr></table></figure><p>값과 pointer를 가지고 있는 Node class를 생성해서, 연결 리스트처럼 구현할 수도 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="comment"># node는 value와 자기 자신의 바로 아래 있는 Node를 가리키는 pointer로 구성된다</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=None, pointer=None)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.pointer = pointer</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Node를 만들고, head에 추가한 다음 Node의 pointer에 추가하기 전 head에 있던 Node를 연결시켜 준다</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.head = Node(value, self.head)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.head:</span><br><span class="line">            value = self.head.value</span><br><span class="line">            self.head = self.head.pointer</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"Stack is empty!"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 연결되어 있는 Node를 탐색하면서 pointer가 None인 마지막 Node까지 출력</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printStack</span><span class="params">(self)</span>:</span></span><br><span class="line">        top = self.head</span><br><span class="line">        <span class="keyword">if</span> top <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            print(<span class="string">"Stack is empty!"</span>)</span><br><span class="line">        <span class="keyword">while</span> top:</span><br><span class="line">            print(top.value, end=<span class="string">' '</span>)</span><br><span class="line">            top = top.pointer</span><br></pre></td></tr></table></figure><h2 id="큐"><a href="#큐" class="headerlink" title="큐"></a>큐</h2><ul><li>큐는 항목이 들어온 순서대로 접근 가능하다. 즉, FIFO(선입선출) 구조이다.</li></ul><h3 id="큐의-동작"><a href="#큐의-동작" class="headerlink" title="큐의 동작"></a>큐의 동작</h3><ul><li>큐의 동작은 크게 <strong>enqueue</strong>와 <strong>dequeue</strong> 가 있다. 각각 맨 뒤쪽에 데이터 삽입, 맨 앞의 데이터 추출 을 수행하는 동작이다.</li></ul><h3 id="큐-구현"><a href="#큐-구현" class="headerlink" title="큐 구현"></a>큐 구현</h3><ul><li>파이썬 list 자료형과 insert() 메서드를 이용하여 구현할 수 있다</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 데이터 추가, 리스트의 맨 앞쪽에 추가한다</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.items.insert(<span class="number">0</span>, value)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 데이터 추출, 처음에 들어온 데이터부터 추출</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.items:</span><br><span class="line">            value = self.items[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">del</span>(self.items[<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"queue is empty!!"</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> repr(self.items)</span><br></pre></td></tr></table></figure><ul><li>리스트의 insert() 메서드는 O(n)의 시간 복잡도를 가진다. <a href="https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt" target="_blank" rel="noopener">참조</a></li></ul><p>2개의 리스트를 사용하면 더 효율적인 큐 구현이 가능하다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.in_items = []</span><br><span class="line">        self.out_items = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_transfer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.in_items:</span><br><span class="line">            self.out_items.append(self.in_items.pop())</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.in_items.append(value)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.out_items:</span><br><span class="line">            self._transfer()</span><br><span class="line">        <span class="keyword">if</span> self.out_items:</span><br><span class="line">            <span class="keyword">return</span> self.out_items.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"queue in empty!"</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.out_items:</span><br><span class="line">            self._transfer()</span><br><span class="line">        <span class="keyword">if</span> self.out_items:</span><br><span class="line">            <span class="keyword">return</span> repr(self.out_items)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"queue in empty!"</span>)</span><br></pre></td></tr></table></figure><ul><li>스택에서 구현한 것 처럼 Node class 를 구현하여 구현할 수도 있다. 스택과 다른 점은 head와 tail 두가지를 추가해 리스트의 시작과 끝을 가리키게 하면 구현할 수 있다.</li></ul><h2 id="데크"><a href="#데크" class="headerlink" title="데크"></a>데크</h2><ul><li>데크는 큐와 스택의 혼합형이라고 할 수 있다. 양쪽 끝에서 데이터의 추가, 삭제가 가능해야 한다.</li><li>구현은 위의 Queue 구현에서 enqueue_back, dequeue_front 만 추가하면 구현할 수 있다.</li></ul><h3 id="파이썬-Deque-모듈"><a href="#파이썬-Deque-모듈" class="headerlink" title="파이썬 Deque 모듈"></a>파이썬 Deque 모듈</h3><ul><li>파이썬의 collections 패키지에는 구현되어 있는 deque 모듈이 있다. 이것을 사용하면 더 효율적으로 사용할 수 있다.</li></ul>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/12/python-datastructure-algo-ch7-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 자료구조와 알고리즘 - 숫자</title>
      <link>https://hbyyy.github.io/2020/05/12/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98ch1/</link>
      <guid>https://hbyyy.github.io/2020/05/12/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98ch1/</guid>
      <pubDate>Tue, 12 May 2020 09:51:56 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;CH-1-숫자&quot;&gt;&lt;a href=&quot;#CH-1-숫자&quot; class=&quot;headerlink&quot; title=&quot;CH 1 : 숫자&quot;&gt;&lt;/a&gt;CH 1 : 숫자&lt;/h1&gt;&lt;h2 id=&quot;정수&quot;&gt;&lt;a href=&quot;#정수&quot; class=&quot;headerlink&quot; title=&quot;정수&quot;&gt;&lt;/a&gt;정수&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;파이썬에서 정수는 int 로 나타내며, 불변형이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;부동소수점&quot;&gt;&lt;a href=&quot;#부동소수점&quot; class=&quot;headerlink&quot; title=&quot;부동소수점&quot;&gt;&lt;/a&gt;부동소수점&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;부동소수점은 IEEE 754 표준을 따른다. 파이썬에서 부동소수점은 float로 나타내고, 불변형이다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;부동소수점은 이진수로 표현되기 때문에. 함부로 비교하거나 연산하면 안 된다. 예를 들어,&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;In : &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0.3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Out: &lt;span class=&quot;literal&quot;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="CH-1-숫자"><a href="#CH-1-숫자" class="headerlink" title="CH 1 : 숫자"></a>CH 1 : 숫자</h1><h2 id="정수"><a href="#정수" class="headerlink" title="정수"></a>정수</h2><ul><li>파이썬에서 정수는 int 로 나타내며, 불변형이다.</li></ul><h2 id="부동소수점"><a href="#부동소수점" class="headerlink" title="부동소수점"></a>부동소수점</h2><ul><li><p>부동소수점은 IEEE 754 표준을 따른다. 파이썬에서 부동소수점은 float로 나타내고, 불변형이다</p><ul><li><p>부동소수점은 이진수로 표현되기 때문에. 함부로 비교하거나 연산하면 안 된다. 예를 들어,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In : <span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span></span><br><span class="line">Out: <span class="literal">False</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>이런 식으로, 논리적으로 맞는 연산이어도 값은 다르게 나오게 된다. 0.1은 이진수로 0.00110011001100…..으로 표현되기 때문에, 연산 시에 정확한 값이 나오지 않을 것이다.</p></li><li><p>정확한 계산을 위해서는, 파이썬 모듈인 decimal을 사용하면 된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line">  In : Decimal(<span class="string">'0.1'</span>) + Decimal(<span class="string">'0.2'</span>) == Decimal(<span class="string">'0.3'</span>)</span><br><span class="line">Out: <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>이렇게 계산이 정확하게 나오게 된다.</p></li></ul></li></ul><h3 id="정수와-부동소수점-메서드"><a href="#정수와-부동소수점-메서드" class="headerlink" title="정수와 부동소수점 메서드"></a>정수와 부동소수점 메서드</h3><ul><li>파이썬의 나누기 연산자(/)는 항상 부동소수점을 반환한다. 정수 나누기 연산자(//)도 존재한다.</li><li>% 연산자는 나머지를 반환한다.</li><li>divmod(x, y) 매서드<ul><li>x를 y로 나눌 때의 몫과 나머지를 반환한다.</li><li>divmod(x, y)  return : (x//y, x%y)</li></ul></li><li>round(x, n) 매서드<ul><li>n이 음수일 때 : x를 n번째 자리에서 반올림한 값</li><li>n이 양수일 때 : x를 소수점 n번째 이하 자리로 반올림한 값</li></ul></li></ul><h2 id="2진수-8진수-16진수"><a href="#2진수-8진수-16진수" class="headerlink" title="2진수, 8진수, 16진수"></a>2진수, 8진수, 16진수</h2><ul><li>파이썬에는 2진수, 8진수, 16진수를 반환하는 함수가 존재한다.<ul><li>2진수 : bin(string)</li><li>8진수 : oct(string)</li><li>16진수 : hex(string)</li></ul></li></ul>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/12/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98ch1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>자료구조 - 해시 테이블</title>
      <link>https://hbyyy.github.io/2020/02/26/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94/</link>
      <guid>https://hbyyy.github.io/2020/02/26/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94/</guid>
      <pubDate>Tue, 25 Feb 2020 18:29:24 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;해쉬-테이블&quot;&gt;&lt;a href=&quot;#해쉬-테이블&quot; class=&quot;headerlink&quot; title=&quot;해쉬 테이블&quot;&gt;&lt;/a&gt;해쉬 테이블&lt;/h2&gt;&lt;h3 id=&quot;용어&quot;&gt;&lt;a href=&quot;#용어&quot; class=&quot;headerlink&quot; title=&quot;용어&quot;&gt;&lt;/a&gt;용어&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;해쉬(hash) : 임의 값을 고정 길이로 변환하는 것&lt;/li&gt;
&lt;li&gt;해쉬 테이블(hash table): 키 값의 연산에 의해 직접 접근이 가능한 테이터 구조&lt;/li&gt;
&lt;li&gt;해싱 함수(hashing function) : key에 대해 산술 연산을 이용해 데이터 위치를 찾을 수 있는 함수&lt;/li&gt;
&lt;li&gt;해쉬 값(hash value) 또는 해쉬 주소(hash address) : key를 해싱 함수로 연산한 값, 이 값의 위치에 해당 key에 대한 값을 저장한다&lt;/li&gt;
&lt;li&gt;슬롯(slot) : 한 개의 데이터를 저장할 수 있는 공간
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="해쉬-테이블"><a href="#해쉬-테이블" class="headerlink" title="해쉬 테이블"></a>해쉬 테이블</h2><h3 id="용어"><a href="#용어" class="headerlink" title="용어"></a>용어</h3><ul><li>해쉬(hash) : 임의 값을 고정 길이로 변환하는 것</li><li>해쉬 테이블(hash table): 키 값의 연산에 의해 직접 접근이 가능한 테이터 구조</li><li>해싱 함수(hashing function) : key에 대해 산술 연산을 이용해 데이터 위치를 찾을 수 있는 함수</li><li>해쉬 값(hash value) 또는 해쉬 주소(hash address) : key를 해싱 함수로 연산한 값, 이 값의 위치에 해당 key에 대한 값을 저장한다</li><li>슬롯(slot) : 한 개의 데이터를 저장할 수 있는 공간<a id="more"></a></li></ul><h3 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h3><h4 id="해쉬-테이블-만들기"><a href="#해쉬-테이블-만들기" class="headerlink" title="해쉬 테이블 만들기"></a>해쉬 테이블 만들기</h4><ol><li>간단한 해시 함수 (Division 이용)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hash_func</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> key % <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ord() -&gt; 문자의 아스키 코드 리턴</span></span><br><span class="line"><span class="comment"># 해쉬 테이블에 데이터를 저장</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">storage_data</span><span class="params">(data, value)</span>:</span></span><br><span class="line">    key = ord(data[<span class="number">0</span>])</span><br><span class="line">    hash_address = hash_func(key)</span><br><span class="line">    hash_table[hash_address] = value</span><br><span class="line"></span><br><span class="line"><span class="comment">#해쉬 테이블에서 해당 데이터의 값을 가져온다</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(data)</span>:</span></span><br><span class="line">    key = ord(data[<span class="number">0</span>])</span><br><span class="line">    hash_address = hash_func(key)</span><br><span class="line">    <span class="keyword">return</span> hash_table[hash_address]</span><br><span class="line">    </span><br><span class="line">data1 = <span class="string">'Andy'</span></span><br><span class="line">data2 = <span class="string">'Dave'</span></span><br><span class="line">data3 = <span class="string">'Trump'</span></span><br><span class="line"></span><br><span class="line">storage_data(<span class="string">'Andy'</span>, <span class="string">'01055553333'</span>)</span><br><span class="line">storage_data(<span class="string">'Dave'</span>, <span class="string">'01012341234'</span>)</span><br><span class="line">storage_data(<span class="string">'Trump'</span>, <span class="string">'01009876543'</span>)</span><br><span class="line"></span><br><span class="line">get_data(<span class="string">'Andy'</span>)</span><br><span class="line"><span class="comment"># '01055553333'</span></span><br></pre></td></tr></table></figure><h3 id="해쉬-테이블의-장단점"><a href="#해쉬-테이블의-장단점" class="headerlink" title="해쉬 테이블의 장단점"></a>해쉬 테이블의 장단점</h3><ul><li>장점<ul><li>데이터 저장/읽기 속도가 빠르다</li><li>데이터의 중복 확인이 쉽다</li></ul></li><li>단점<ul><li>저장 공간이 많이 필요하다.</li><li>키가 충돌할 경우 처리할 별도의 자료구조가 필요하다<ul><li>공간을 늘리는 것으로 어느정도 해결이 가능</li></ul></li></ul></li></ul><h3 id="충돌-해결-알고리즘"><a href="#충돌-해결-알고리즘" class="headerlink" title="충돌 해결 알고리즘"></a>충돌 해결 알고리즘</h3><blockquote><p>다른 data 가 값은 해쉬 값을 가지는 것을 충돌이라 한다.</p></blockquote><h4 id="Chaining-기법"><a href="#Chaining-기법" class="headerlink" title="Chaining 기법"></a>Chaining 기법</h4><ul><li>해쉬 테이블 외의 저장공간을 이용<ul><li><strong>개방 해싱(Open hashing)</strong> 기법</li></ul></li><li>충돌이 일어나면, 링크드 리스트로 데이터를 뒤에 연결함</li></ul><h4 id="Linear-Probing-기법"><a href="#Linear-Probing-기법" class="headerlink" title="Linear Probing 기법"></a>Linear Probing 기법</h4><ul><li>해쉬 테이블 내의 저장공간을 이용<ul><li><strong>폐쇄 해슁(Close hashing)</strong> 기법</li></ul></li><li>충돌이 일어나면, 해당 hash address의 다음 address부터 맨 처음 나오는 빈 공간에 저장</li></ul><h4 id="Chaining-기법-예시"><a href="#Chaining-기법-예시" class="headerlink" title="Chaining 기법 예시"></a>Chaining 기법 예시</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_key</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hash(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hash_func</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> key % <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_data</span><span class="params">(data, value)</span>:</span></span><br><span class="line">    index_key = get_key(data)</span><br><span class="line">    hash_address = hash_func(index_key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hash_table2[hash_address]:</span><br><span class="line">        hash_table2[hash_address].append([index_key, value])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> hash_table2[hash_address]:</span><br><span class="line">            <span class="keyword">if</span> index[<span class="number">0</span>] == index_key:</span><br><span class="line">                index[<span class="number">1</span>] = value</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        hash_table2[hash_address].append([index_key, value])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">(data)</span>:</span></span><br><span class="line">    index_key = get_key(data)</span><br><span class="line">    hash_address = hash_func(index_key)</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> hash_table2[hash_address]:</span><br><span class="line">        <span class="keyword">if</span> index[<span class="number">0</span>] == index_key:</span><br><span class="line">            print(index[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> index[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">'데이터가 없습니다'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/02/26/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94/#disqus_thread</comments>
    </item>
    
    <item>
      <title>OS - 컨텍스트 스위칭</title>
      <link>https://hbyyy.github.io/2020/02/16/OS-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%8A%A4%EC%9C%84%EC%B9%AD/</link>
      <guid>https://hbyyy.github.io/2020/02/16/OS-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%8A%A4%EC%9C%84%EC%B9%AD/</guid>
      <pubDate>Sat, 15 Feb 2020 18:07:06 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;컨텍스트-스위칭이란&quot;&gt;&lt;a href=&quot;#컨텍스트-스위칭이란&quot; class=&quot;headerlink&quot; title=&quot;컨텍스트 스위칭이란&quot;&gt;&lt;/a&gt;컨텍스트 스위칭이란&lt;/h3&gt;&lt;p&gt; 운영체제의 스케줄러는 자원의 낭비를 최소화하기 위해 여러 프로세스를 계속해서 번갈아가며 실행하는 멀티프로그래밍 방식으로 프로세스를 실행한다.&lt;/p&gt;
&lt;p&gt;프로세스 A, B가 실행 중이라고 가정해보자. A 프로세스가 running  상태이고, B 프로세스가 ready 상태일 때, 스케줄러가  A 프로세서에서 B 프로세서로 실행하는 프로세스를 바꾸는 것이 &lt;strong&gt;컨텍스트 스위칭&lt;/strong&gt; 이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="컨텍스트-스위칭이란"><a href="#컨텍스트-스위칭이란" class="headerlink" title="컨텍스트 스위칭이란"></a>컨텍스트 스위칭이란</h3><p> 운영체제의 스케줄러는 자원의 낭비를 최소화하기 위해 여러 프로세스를 계속해서 번갈아가며 실행하는 멀티프로그래밍 방식으로 프로세스를 실행한다.</p><p>프로세스 A, B가 실행 중이라고 가정해보자. A 프로세스가 running  상태이고, B 프로세스가 ready 상태일 때, 스케줄러가  A 프로세서에서 B 프로세서로 실행하는 프로세스를 바꾸는 것이 <strong>컨텍스트 스위칭</strong> 이다.</p><a id="more"></a><h3 id="PCB란"><a href="#PCB란" class="headerlink" title="PCB란"></a>PCB란</h3><p> 컨텍스트 스위칭이 일어날 때, 프로세스는 프로세스가 실행되는 상태의 모든 정보를 <strong>PCB(Process Control Block)</strong>란 자료구조에 저장하고, 이것은 메인 메모리에 저장된다. </p><p> 스케줄러가 이 프로세스를 다시 실행하려고 한다면 , PCB에 있는 정보를 CPU에 다시 넣고 실행하게 된다. 이런 과정을 통해 예전에 실행하던 프로세스의 정보를 그대로 가져와 중지된 부분부터 다시 실행할 수 있게 된다.</p>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/02/16/OS-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%8A%A4%EC%9C%84%EC%B9%AD/#disqus_thread</comments>
    </item>
    
    <item>
      <title>OS - 프로세스 구조</title>
      <link>https://hbyyy.github.io/2020/02/14/OS-process%EA%B5%AC%EC%A1%B0/</link>
      <guid>https://hbyyy.github.io/2020/02/14/OS-process%EA%B5%AC%EC%A1%B0/</guid>
      <pubDate>Thu, 13 Feb 2020 16:50:51 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;프로세스란&quot;&gt;&lt;a href=&quot;#프로세스란&quot; class=&quot;headerlink&quot; title=&quot;프로세스란?&quot;&gt;&lt;/a&gt;프로세스란?&lt;/h3&gt;&lt;p&gt;프로세스란 간단히 정리하면 &lt;strong&gt;실행 중인 프로그램&lt;/strong&gt; 이라고 할 수 있습니다. &lt;strong&gt;프로그램&lt;/strong&gt;은 실행 하기 전에는 보조 기억 장치(SSD나 HDD)에 저장되어 실행을 기다리고 있는데,  이 프로그램이 실행을 요청받아 메모리에 적재된다면 프로세스가 됩니다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="프로세스란"><a href="#프로세스란" class="headerlink" title="프로세스란?"></a>프로세스란?</h3><p>프로세스란 간단히 정리하면 <strong>실행 중인 프로그램</strong> 이라고 할 수 있습니다. <strong>프로그램</strong>은 실행 하기 전에는 보조 기억 장치(SSD나 HDD)에 저장되어 실행을 기다리고 있는데,  이 프로그램이 실행을 요청받아 메모리에 적재된다면 프로세스가 됩니다.</p><a id="more"></a><h3 id="프로세스의-구조"><a href="#프로세스의-구조" class="headerlink" title="프로세스의 구조"></a>프로세스의 구조</h3><p><img src="https://images.velog.io/post-images/pa324/06db2c70-1242-11ea-9735-834e8b45e32e/image.png" alt="프로세스 구조 이미지 검색결과"></p><p>프로세스는 일반적으로 code, data, heap, stack 영역으로 이루어집니다.</p><ol><li><strong>Text(Code) 영역</strong><ul><li>Text 영역은 프로그램의 코드가 저장되는 영역이다.   CPU는 이곳에 저장되어 있는 코드를 한 줄씩 실행시키고, PC(process counter)가 다음 실행할 코드의 주소를 가리키고 있습니다.</li></ul></li></ol><ol start="2"><li><strong>data 영역</strong><ul><li>data 영역은 전역 변수, 정적 변수 등의 데이터가 저장되는 공간입니다. </li></ul></li></ol><ol start="3"><li><strong>Heap 영역</strong><ul><li>Heap 영역은 프로그램 실행 시 동적으로 할당되는 데이터가 저장되는 공간입니다.. 이 공간은 사용자가 직접 관리할 수 있습니다.</li></ul></li></ol><ol start="4"><li><strong>Stack 영역</strong><ul><li>Stack 영역은 프로그램에서 함수 호출 시, 함수의 정보가 저장되는 영역입니다. 지역 변수, 매개 변수, 함수 종료시 돌아갈 리턴 주소 등이 저장되는데, 이 구조를 스택 프레임이라고 합나다.  Stack 영역이라는 이름답게 FIFO 방식으로 데이터가 push되고 pop 됩니다.</li><li>스택의 최상단 부분을 SP(Stack pointer)가 가리키고 있습니다.</li></ul></li></ol><p>프로세스는 일반적으로 다음과 같은 구조를 가지고 있고, 각각의 이름은 운영체제마다 조금씩 차이가 있습니다.</p>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/02/14/OS-process%EA%B5%AC%EC%A1%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django Rest Framework Tutorial (1)</title>
      <link>https://hbyyy.github.io/2020/02/12/DRFTutorial-1/</link>
      <guid>https://hbyyy.github.io/2020/02/12/DRFTutorial-1/</guid>
      <pubDate>Wed, 12 Feb 2020 14:41:06 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;Django 는 REST API 를 만들 수 있는 &lt;strong&gt;Django REST Framework(DRF)&lt;/strong&gt; 가 존재한다. Django는 기본적으로 풀스택 프레임워크로 동작하지만, &lt;strong&gt;DRF&lt;/strong&gt;를 사용한다면 클라이언트와 분리된 완전한 백엔드 프레임워크로 동작하게&lt;br&gt;만들 수 있다.  &lt;/p&gt;
&lt;p&gt;Django는 백엔드에서 실제로 HTML 코드를 만들어 클라이언트에 전달해주는 동작으로 서비스를 구현한다. 하지만, DRF는 직렬화한 데이터(주로 JSON 형식이 많이 쓰인다) 를 클라이언트에 보내주는 역할을 한다.&lt;/p&gt;
&lt;p&gt;이 포스트에서는 &lt;a href=&quot;https://www.django-rest-framework.org/tutorial/1-serialization/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Django REST Framework tutorial&lt;/a&gt; 을 따라가며 한글로 번역하고, 기본적인 DRF의 사용법을 정리할 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;들어가기에 앞서, 이 튜토리얼은 간단한 코드 하이라이팅 웹 API를 구현하는 식으로 진행된다.&lt;/p&gt;
&lt;h2 id=&quot;프로젝트-설정&quot;&gt;&lt;a href=&quot;#프로젝트-설정&quot; class=&quot;headerlink&quot; title=&quot;프로젝트 설정&quot;&gt;&lt;/a&gt;프로젝트 설정&lt;/h2&gt;&lt;p&gt;프로젝트를 만들기 전에, 먼저 가상환경을 설정해준다. &lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>Django 는 REST API 를 만들 수 있는 <strong>Django REST Framework(DRF)</strong> 가 존재한다. Django는 기본적으로 풀스택 프레임워크로 동작하지만, <strong>DRF</strong>를 사용한다면 클라이언트와 분리된 완전한 백엔드 프레임워크로 동작하게<br>만들 수 있다.  </p><p>Django는 백엔드에서 실제로 HTML 코드를 만들어 클라이언트에 전달해주는 동작으로 서비스를 구현한다. 하지만, DRF는 직렬화한 데이터(주로 JSON 형식이 많이 쓰인다) 를 클라이언트에 보내주는 역할을 한다.</p><p>이 포스트에서는 <a href="https://www.django-rest-framework.org/tutorial/1-serialization/" target="_blank" rel="noopener">Django REST Framework tutorial</a> 을 따라가며 한글로 번역하고, 기본적인 DRF의 사용법을 정리할 것이다.</p></blockquote><p>들어가기에 앞서, 이 튜토리얼은 간단한 코드 하이라이팅 웹 API를 구현하는 식으로 진행된다.</p><h2 id="프로젝트-설정"><a href="#프로젝트-설정" class="headerlink" title="프로젝트 설정"></a>프로젝트 설정</h2><p>프로젝트를 만들기 전에, 먼저 가상환경을 설정해준다. </p><a id="more"></a><p><code>pyenv</code> 를 이용한 설정</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pyenv virtualenv 3.7.5 drf-tutorial-env</span><br><span class="line">pyenv local drf-tutorial-env</span><br></pre></td></tr></table></figure><p>다음으로, 필요한 패키지들을 설치해 준다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install django</span><br><span class="line">pip install djangorestframework</span><br><span class="line">pip install pygments# 코드 하이라이팅을 위한 패키지</span><br></pre></td></tr></table></figure><p>필요한 패키지 설치 후, Django Project를 생성하고, app을 만들어 준다. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">django-admin startproject tutorial# 프로젝트 생성</span><br><span class="line">cd tutorial</span><br><span class="line">./manage.py startapp snippets# app 생성</span><br></pre></td></tr></table></figure><p><strong><code>tutorial/settings.py</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'rest_framework'</span>,</span><br><span class="line">    <span class="string">'snippets.apps.SnippetsConfig'</span>,</span><br><span class="line">    ...,</span><br><span class="line">    ...,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="Snippet-모델-구현"><a href="#Snippet-모델-구현" class="headerlink" title="Snippet 모델 구현"></a>Snippet 모델 구현</h3><p>Snippet 모델에는 created, title, code, linenos, language, style 6가지 필드가 존재한다.</p><p>튜토리얼에서는 코드 하이라이팅 기능을 구현하기 위해 pygmens 패키지를 사용한다.</p><p><strong><code>snippets/models.py</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> pygments.lexers <span class="keyword">import</span> get_all_lexers</span><br><span class="line"><span class="keyword">from</span> pygments.styles <span class="keyword">import</span> get_all_styles</span><br><span class="line"></span><br><span class="line"><span class="comment"># pygments에서 지원하는 모든 언어 정보를 가져온다.</span></span><br><span class="line">LEXERS = [item <span class="keyword">for</span> item <span class="keyword">in</span> get_all_lexers() <span class="keyword">if</span> item[<span class="number">1</span>]]</span><br><span class="line">LANGUAGE_CHOICES = sorted([(item[<span class="number">1</span>][<span class="number">0</span>], item[<span class="number">0</span>]) <span class="keyword">for</span> item <span class="keyword">in</span> LEXERS])</span><br><span class="line"><span class="comment"># pygments에서 지원하는 모든 코드 스타일들을 가져온다.</span></span><br><span class="line">STYLE_CHOICES = sorted([(item, item) <span class="keyword">for</span> item <span class="keyword">in</span> get_all_styles()])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snippet</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    created = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>, blank=<span class="literal">True</span>, default=<span class="string">''</span>)</span><br><span class="line">    code = models.TextField()</span><br><span class="line">    linenos = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line">    language = models.CharField(choices=LANGUAGE_CHOICES, default=<span class="string">'python'</span>, max_length=<span class="number">100</span>)</span><br><span class="line">    style = models.CharField(choices=STYLE_CHOICES, default=<span class="string">'friendly'</span>, max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        ordering = [<span class="string">'created'</span>]</span><br></pre></td></tr></table></figure><p>모델 구현 후에는 <em>makemigrations</em>, <em>migrate</em> 를 진행해 주자.</p><h3 id="Serializer-구현"><a href="#Serializer-구현" class="headerlink" title="Serializer 구현"></a>Serializer 구현</h3><p><strong>serializer</strong> 는 DRF의 핵심이다. serializer는 파이썬 클래스 인스턴스 형식의 데이터(snippet)를 직렬화하여 JSON 같은 데이터 형식으로 표현해 주거나, 반대로 JSON 같은 데이터 형식의 데이터를 파이썬 클래스 인스턴스 형식의 데이터로 역 직렬화 해주는 역할을 한다.</p><p>  <strong>serializer</strong>  의 구현은  django form과 비슷한 면이 있다. 다음의 코드를 보자</p><ul><li>serializer.py 파일을 만들어 준다.</li></ul><p><strong><code>snippets/serializer.py</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> snippets.models <span class="keyword">import</span> Snippet, LANGUAGE_CHOICES, STYLE_CHOICES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnippetSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    id = serializers.IntegerField(read_only=<span class="literal">True</span>)</span><br><span class="line">    title = serializers.CharField(required=<span class="literal">False</span>, allow_blank=<span class="literal">True</span>, max_length=<span class="number">100</span>)</span><br><span class="line">    code = serializers.CharField(required=<span class="literal">True</span>, style=&#123;<span class="string">'base_template'</span>: <span class="string">'textarea.html'</span>&#125;)</span><br><span class="line">    linenos = serializers.BooleanField(required=<span class="literal">False</span>)</span><br><span class="line">    language = serializers.ChoiceField(choices=LANGUAGE_CHOICES, default=<span class="string">'python'</span>)</span><br><span class="line">    style = serializers.ChoiceField(choices=STYLE_CHOICES, default=<span class="string">'friendly'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        validation을 통과한 validated_data로 새로운 snippet instance 를 생성힌디.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> Snippet.objects.create(**validated_data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, instance, validated_data)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        validation을 통과한 validated_data로 이미 존재하는 snippet instance를 변경한다.</span></span><br><span class="line"><span class="string">        변경을 요청하지 않은 데이터는 기존 instance의 데이터를 넣는다.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        instance.title = validated_data.get(<span class="string">'title'</span>, instance.title)</span><br><span class="line">        instance.code = validated_data.get(<span class="string">'code'</span>, instance.code)</span><br><span class="line">        instance.linenos = validated_data.get(<span class="string">'linenos'</span>, instance.linenos)</span><br><span class="line">        instance.language = validated_data.get(<span class="string">'language'</span>, instance.language)</span><br><span class="line">        instance.style = validated_data.get(<span class="string">'style'</span>, instance.style)</span><br><span class="line">        instance.save()</span><br><span class="line">        <span class="keyword">return</span> instance</span><br></pre></td></tr></table></figure><p>첫번째로, 직렬화와 역 직렬화를 하는 필드들을 정의해준다. 필드들은 form과 같이 필드를 정의할 때 <strong>default</strong>, <strong>read_only</strong> 등등의 <strong>validation flag</strong>를 포함해 선언한다.</p><p><strong>style</strong> flag 는 django form의 widget처럼 HTML로 렌더링 하는 방법을 설정해 줄 수 있다.  </p><ul><li>필드들의 자세한 정보는 <a href="https://www.django-rest-framework.org/api-guide/fields/" target="_blank" rel="noopener">여기</a>를 참조하자. </li></ul><p>다음으로, <strong><code>create()</code></strong>, <strong><code>update()</code></strong> 메소드는 <strong><code>serializer.save()</code></strong> 를 실행할 때 동작할 코드들을 정의해 주는 것이다.</p><h3 id="Serialization-Deserialization-테스트"><a href="#Serialization-Deserialization-테스트" class="headerlink" title="Serialization, Deserialization 테스트"></a>Serialization, Deserialization 테스트</h3><p>이제 지금까지 구현한 Snippet model과  Serializer를 이용하여 직렬화, 역 직렬화를 테스트 해보자.</p><ol><li>Serialization</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> snippets.models <span class="keyword">import</span> Snippet</span><br><span class="line"><span class="keyword">from</span> snippets.serializers <span class="keyword">import</span> SnippetSerializer</span><br><span class="line"><span class="keyword">from</span> rest_framework.renderers <span class="keyword">import</span> JSONRenderer</span><br><span class="line"><span class="keyword">from</span> rest_framework.parsers <span class="keyword">import</span> JSONParser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">snippet = Snippet.objects.create(code=<span class="string">'foo = "bar"\n'</span>)                   </span><br><span class="line">snippet = Snippet.objects.create(code=<span class="string">'print("Hello world!")\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># serializer를 만들고 생성한 snippet instance를 넣어준다.</span></span><br><span class="line"><span class="comment"># serializer가 snippet instance를 python dictionary 형태로 변환해 준다.</span></span><br><span class="line">serializer = SnippetSerializer(snippet)                                 </span><br><span class="line">serializer.data                                                         </span><br><span class="line"><span class="comment"># &#123;'id': 3, 'title': '', 'code': 'print("Hello world!")\n', 'linenos': False, 'language': 'python', 'style': 'friendly'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python 데이터 형태를 JSON으로 변환</span></span><br><span class="line">content = JSONRenderer().render(serializer.data)</span><br><span class="line">content                                                                 </span><br><span class="line"><span class="comment"># b'&#123;"id":3,"title":"","code":"print(\\"Hello world!\\")\\n","linenos":false,"language":"python","style":"friendly"&#125;'</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Deserialization</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 데이터 스트림을 파이썬 기본 데이터 형으로 변환해 준다.</span></span><br><span class="line">stream = io.BytesIO(content)</span><br><span class="line">data = JSONParser().parse(stream)</span><br><span class="line">data</span><br><span class="line"><span class="comment"># &#123;'id': 3, 'title': '', 'code': 'print("Hello world!")\n', 'linenos': False, 'language': 'python', 'style': 'friendly'&#125;</span></span><br><span class="line"></span><br><span class="line">serializer = SnippetSerializer(data=data)</span><br><span class="line">serializer.is_valid()</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">serializer.validated_data</span><br><span class="line"><span class="comment"># OrderedDict([('title', ''),</span></span><br><span class="line"><span class="comment">#             ('code', 'print("Hello world!")'),</span></span><br><span class="line"><span class="comment">#             ('linenos', False),</span></span><br><span class="line"><span class="comment">#             ('language', 'python'),</span></span><br><span class="line"><span class="comment">#             ('style', 'friendly')])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># serializer 정의 시에 정의해 준 동작 실행 (create)</span></span><br><span class="line">serializer.save()</span><br></pre></td></tr></table></figure><ul><li>serializer에 queryset을 넣어 줄 수도 있다. 이 경우 <code>many=True</code> 옵션을 지정해 주어야 한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serializer = SnippetSerializer(Snippet.objects.all(), many=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="ModelSerializers-사용"><a href="#ModelSerializers-사용" class="headerlink" title="ModelSerializers 사용"></a>ModelSerializers 사용</h3><p>Django의 ModelForm처럼, Serializer도 ModelSerializers를 사용할 수 있다 이것을 사용한다면 훨씬 간편하게 serializer를 만들 수 있다.</p><p><strong><code>snippets/serializer.py</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnippetSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Snippet</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'code'</span>, <span class="string">'linenos'</span>, <span class="string">'language'</span>, <span class="string">'style'</span>]</span><br></pre></td></tr></table></figure><p>간단하게 serializer 가 구현되었다. create()와 update()같은 메소드들은 기본적으로 구현이 되어 있다.</p><p>ModelSerializer의 구현 내용은 다음과 같이 확인할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">serializer = SnippetSerializer()                                         </span><br><span class="line">print(repr(serializer))                                                        </span><br><span class="line"><span class="comment"># SnippetSerializer():</span></span><br><span class="line"><span class="comment">#    id = IntegerField(read_only=True)</span></span><br><span class="line"><span class="comment">#    title = CharField(allow_blank=True, max_length=100, required=False)</span></span><br><span class="line"><span class="comment">#    code = CharField(required=True, style=&#123;'base_template': 'textarea.html'&#125;)</span></span><br><span class="line"><span class="comment">#    linenos = BooleanField(required=False)</span></span><br><span class="line"><span class="comment">#    language = ChoiceField(choices=[</span></span><br><span class="line"><span class="comment">#    .....</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/02/12/DRFTutorial-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python - Class 정리</title>
      <link>https://hbyyy.github.io/2020/02/11/python-class/</link>
      <guid>https://hbyyy.github.io/2020/02/11/python-class/</guid>
      <pubDate>Tue, 11 Feb 2020 13:33:39 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;클래스&quot;&gt;&lt;a href=&quot;#클래스&quot; class=&quot;headerlink&quot; title=&quot;클래스&quot;&gt;&lt;/a&gt;클래스&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;객체를 만들기 위한 틀, 클래스 자체도 객체이다&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 클래스 예시&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Gen&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.number = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;plus_number&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.number += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__init__(self)&lt;/code&gt; : 생성자의 역할, 클래스에 &lt;strong&gt;필수로&lt;/strong&gt; 정의되야 한다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;self&lt;/code&gt; : 클래스 자신을 카리킨다&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h1><ul><li>객체를 만들기 위한 틀, 클래스 자체도 객체이다</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 클래스 예시</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gen</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.number = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plus_number</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.number += <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><code>__init__(self)</code> : 생성자의 역할, 클래스에 <strong>필수로</strong> 정의되야 한다</li><li><code>self</code> : 클래스 자신을 카리킨다</li></ul><a id="more"></a><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul><li>파이썬에서 private로 변수를 지정하려면, <code>__변수명</code> 식으로 선언하면 된다.<ul><li>하지만 이 변수에 외부에서 접근이 불가능하지 않다. private로 선언한 변수는 클래스 내부에 <code>__클래스명__변수명</code> 으로 저장되는데, 이것을 <strong>네임 맹글링</strong>이라고 한다.</li><li><code>_변수명</code>은  protected 지정자이다. 하지만 이것은 파이썬 사용자들간의 약속일 뿐 아무런 접근 제한도 존재하지 않는다.</li></ul></li></ul><h2 id="Getter-Setter"><a href="#Getter-Setter" class="headerlink" title="Getter, Setter"></a>Getter, Setter</h2><ul><li>getter, setter는 다른 언어처럼 따로 작성하지 않는다</li></ul><h3 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h3><ul><li><p>데코레이터인 <code>@property</code>를 이용해 작성한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#getter 예시</span></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>이렇게 하면 <code>인스턴스.변수명</code> 으로 함수 호출이 아닌 표현식 처럼 사용이 가능하다.</p></li><li><p>이렇게 사용하는 이유는, 외부에서 클래스 변수에 접근하여 변경하는 것을 막기 위해서이다</p></li></ul><h3 id="Setter"><a href="#Setter" class="headerlink" title="Setter"></a>Setter</h3><ul><li>getter를 먼저 생성해야 만들 수 있다</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@name.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, ...)</span>:</span></span><br><span class="line">self.name = ...</span><br></pre></td></tr></table></figure><ul><li>이렇게 만드는 이유는 ,  setter를 만들 때 입력 조건 형성이 가능하게 된다.</li></ul><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="Instance-method"><a href="#Instance-method" class="headerlink" title="Instance method"></a>Instance method</h3><ul><li><p>첫번째 인자로 <code>self</code>를 가진다</p></li><li><p>인스턴스를 이용해 호출</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gen</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.number = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 인스턴스 매서드</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plus_number</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.number += <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Class-method"><a href="#Class-method" class="headerlink" title="Class method"></a>Class method</h3><ul><li><p>첫번째 인자로 <code>cls</code> 를 가진다</p></li><li><p><code>cls</code>는 클래스 자체를 의미한다</p></li><li><p>클래스 매서드는 클래스 속성에 대해 동작한다</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gen</span>:</span></span><br><span class="line">    description : <span class="string">'++number++'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.number = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 인스턴스 매서드</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plus_number</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.number += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#클래스 매서드는 @classmethod 데코레이터를 사용한다</span></span><br><span class="line">    <span class="comment">#Gen의 클래스 속성인 description을 출력한다</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_desc</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(cls.description)</span><br><span class="line">        </span><br><span class="line"><span class="comment">#사용 예시, 클래스 자체를 사용</span></span><br><span class="line">Gen.print_desc()</span><br></pre></td></tr></table></figure></li></ul><h3 id="Static-method"><a href="#Static-method" class="headerlink" title="Static method"></a>Static method</h3><ul><li><p>클래스 내부에 정의된 일반 함수이다</p></li><li><p>클래스나 인스턴스를 통해 접근 가능</p></li><li><p>클래스나 인스턴스에 영향을 줄 수 없다</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gen</span>:</span></span><br><span class="line">    description : <span class="string">'++number++'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        self.number = number</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 정적 매서드는 @staticmethod 데코레이터를 사용한다</span></span><br><span class="line">    <span class="comment"># 1 - 100 범위의 임의의 수로 Gen 클래스의 인스턴스를 생성</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plus_gen</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Gen(random.randint(<span class="number">1</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h2><ul><li>부모 클래스의 기능들을 사용할 수 있게 한다</li><li>같은 이름의 내부 함수를 오버라이딩 할 수 있다</li><li><code>super()</code> 를 사용하면 부모 클래스의 함수를 사용할 수 있다</li></ul><h2 id="동적-바인딩"><a href="#동적-바인딩" class="headerlink" title="동적 바인딩"></a>동적 바인딩</h2><ul><li>타입을 신경쓰지 않고 인스턴스를 사용 가능하게 한다</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_bark</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'멍멍'</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_bark</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'야옹'</span>)</span><br><span class="line">        </span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">animal_sound</span><span class="params">(animal)</span>:</span></span><br><span class="line">    animal.bark()</span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="string">'A'</span>)</span><br><span class="line">cat = Cat(<span class="string">'B'</span>)</span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="string">'A'</span>)</span><br><span class="line">cat = Cat(<span class="string">'B'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#결과 : 멍멍</span></span><br><span class="line"><span class="comment">#   야옹</span></span><br></pre></td></tr></table></figure><ul><li>위에서 animal_sound() 함수는 여러 역할을 할 수 있다, Dog 클래스의 bark()를 실행할 수도 있고 Cat 클래스의 bark()를 실행할 수도 있다. 이것을 <strong>다형성</strong> 이라고 한다.</li><li>또, 이 함수에서는, 인자에 Dog, Cat중 어떤 클래스가 들어가더라도 클래스의 bark()를 제대로 실행하게 된다</li><li>즉, 동적으로 바인딩할 때, 인자의 타입에 영향을 받지 않고, 오직 <strong>객체</strong>가 <strong>해당 속성</strong>을 가졌는지만 검사한다.</li><li>위의 예시에서는 인자가 bark() 메서드를 가졌는지만 검사한다.</li></ul><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><p><a href="https://lhy.kr/" target="_blank" rel="noopener">lhy’s blog</a></p></li><li><p>강의자료</p></li><li><p><a href="http://pythonstudy.xyz/" target="_blank" rel="noopener">예제로 배우는 파이썬 프로그래밍</a></p></li></ul>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/02/11/python-class/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
