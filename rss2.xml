<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>hbyyy&#39;s blog</title>
    <link>https://hbyyy.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Fri, 05 Jun 2020 13:37:45 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>TIL-20200605</title>
      <link>https://hbyyy.github.io/2020/06/05/TIL-20200605/</link>
      <guid>https://hbyyy.github.io/2020/06/05/TIL-20200605/</guid>
      <pubDate>Fri, 05 Jun 2020 13:37:16 GMT</pubDate>
      <description>
      
        
        
          &lt;ol&gt;
&lt;li&gt;알고리즘&lt;ul&gt;
&lt;li&gt;이진 탐색 트리(BST) 공부하고 정리했다. 주말에 정리해서 포스팅 할 것이다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;프로젝트&lt;ol&gt;
&lt;li&gt;뉴스 메일링 프로젝트 &lt;ul&gt;
&lt;li&gt;django + 간단한 javasc
        
      
      </description>
      
      
      <content:encoded><![CDATA[<ol><li>알고리즘<ul><li>이진 탐색 트리(BST) 공부하고 정리했다. 주말에 정리해서 포스팅 할 것이다</li></ul></li><li>프로젝트<ol><li>뉴스 메일링 프로젝트 <ul><li>django + 간단한 javascript 공부해서 구현하기로 정했다.</li><li>members model 추가, 테스트 코드 추가</li><li>github action, codecov 적용</li></ul></li></ol></li></ol>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/06/05/TIL-20200605/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TIL-20200604</title>
      <link>https://hbyyy.github.io/2020/06/04/TIL-20200604/</link>
      <guid>https://hbyyy.github.io/2020/06/04/TIL-20200604/</guid>
      <pubDate>Thu, 04 Jun 2020 13:36:27 GMT</pubDate>
      <description>
      
        
        
          &lt;ol&gt;
&lt;li&gt;SQL&lt;ul&gt;
&lt;li&gt;SQL 첫걸음 책 6강까지 완료&lt;ul&gt;
&lt;li&gt;SELECT 구문&lt;/li&gt;
&lt;li&gt;데이터베이스 자료형 (int, date, time, char, varchar)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<ol><li>SQL<ul><li>SQL 첫걸음 책 6강까지 완료<ul><li>SELECT 구문</li><li>데이터베이스 자료형 (int, date, time, char, varchar)</li></ul></li></ul></li><li>운영체제<ul><li>프로세서, 메모리<ul><li>프로세서의 구조</li><li>레지스터 종류</li><li>명령어</li></ul></li></ul></li><li>프로젝트<ol><li>뉴스 메일링 프로젝트 <ul><li>scrapy 튜토리얼 완료, 크롤링 코드 어떻게 짤지 생각해보자..</li><li>members app 추가, 프로젝트 timezone 세팅, 템플릿 경로 세팅</li></ul></li></ol></li></ol>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/06/04/TIL-20200604/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TIL-20200603</title>
      <link>https://hbyyy.github.io/2020/06/03/TIL-20200603/</link>
      <guid>https://hbyyy.github.io/2020/06/03/TIL-20200603/</guid>
      <pubDate>Wed, 03 Jun 2020 10:13:44 GMT</pubDate>
      <description>
      
        
        
          &lt;ol&gt;
&lt;li&gt;파이썬 자료구조와 알고리즘&lt;ul&gt;
&lt;li&gt;병합 정렬, 퀵 정렬 정리&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;알고리즘 문제풀이&lt;ol&gt;
&lt;li&gt;백준 10814, 11650, 10989 성공&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;프로젝트&lt;ol
        
      
      </description>
      
      
      <content:encoded><![CDATA[<ol><li>파이썬 자료구조와 알고리즘<ul><li>병합 정렬, 퀵 정렬 정리</li></ul></li><li>알고리즘 문제풀이<ol><li>백준 10814, 11650, 10989 성공</li></ol></li><li>프로젝트<ol><li>뉴스 메일링 프로젝트 다시 시작<ul><li>프로젝트 초기 세팅 완료</li><li>scrapy tutorial 시작</li></ul></li></ol></li></ol>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/06/03/TIL-20200603/#disqus_thread</comments>
    </item>
    
    <item>
      <title>최소공배수와 최대공약수</title>
      <link>https://hbyyy.github.io/2020/05/28/gcd-lcm-20200528/</link>
      <guid>https://hbyyy.github.io/2020/05/28/gcd-lcm-20200528/</guid>
      <pubDate>Thu, 28 May 2020 13:14:50 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;파이썬으로 최대공약수, 최소공배수 구하기&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;최대공약수&quot;&gt;&lt;a href=&quot;#최대공약수&quot; class=&quot;headerlink&quot; title=&quot;최대공약수&quot;&gt;&lt;/a&gt;최대공약수&lt;/h1&gt;&lt;h2 id=&quot;최대공약수란&quot;&gt;&lt;a href=&quot;#최대공약수란&quot; class=&quot;headerlink&quot; title=&quot;최대공약수란?&quot;&gt;&lt;/a&gt;최대공약수란?&lt;/h2&gt;&lt;p&gt; 최대공약수는 0이 아닌 정수들 사이의 공약수 중 &lt;strong&gt;가장 큰&lt;/strong&gt; 공약수를 말한다.&lt;/p&gt;
&lt;h2 id=&quot;구현&quot;&gt;&lt;a href=&quot;#구현&quot; class=&quot;headerlink&quot; title=&quot;구현&quot;&gt;&lt;/a&gt;구현&lt;/h2&gt;&lt;h3 id=&quot;단순한-계산식-이용&quot;&gt;&lt;a href=&quot;#단순한-계산식-이용&quot; class=&quot;headerlink&quot; title=&quot;단순한 계산식 이용&quot;&gt;&lt;/a&gt;단순한 계산식 이용&lt;/h3&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>파이썬으로 최대공약수, 최소공배수 구하기</p></blockquote><h1 id="최대공약수"><a href="#최대공약수" class="headerlink" title="최대공약수"></a>최대공약수</h1><h2 id="최대공약수란"><a href="#최대공약수란" class="headerlink" title="최대공약수란?"></a>최대공약수란?</h2><p> 최대공약수는 0이 아닌 정수들 사이의 공약수 중 <strong>가장 큰</strong> 공약수를 말한다.</p><h2 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h2><h3 id="단순한-계산식-이용"><a href="#단순한-계산식-이용" class="headerlink" title="단순한 계산식 이용"></a>단순한 계산식 이용</h3><a id="more"></a><ul><li>0이 아닌 두 정수 M, N 이 있다면, 1부터 둘 중 작은 수까지 나누어 보고, 나눠지는 수 중 가장 큰 수가 최대공약수일 것이다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">N, M = <span class="number">100</span>, <span class="number">450</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, min(N, M) +<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> N % num == <span class="number">0</span> <span class="keyword">and</span> M % num == <span class="number">0</span>:</span><br><span class="line">        GCD = num</span><br><span class="line">print(GCD)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">50</span></span><br></pre></td></tr></table></figure><p>위의 풀이로 계산을 한다면, 시간 복잡도는 <strong>O(N)</strong>이다.</p><h3 id="유클리드-호제법"><a href="#유클리드-호제법" class="headerlink" title="유클리드 호제법"></a>유클리드 호제법</h3><p> 유클리드 호제법은 2개의 자연수의 최대공약수를 구하는 알고리즘이다.</p><h4 id="정의"><a href="#정의" class="headerlink" title="정의"></a>정의</h4><p>2개의 자연수 a, b (a &gt; b)에 대해 a를 b로 나눈 나머지가 r이라고 하면, a와 b의 최대공약수는 b와 r의 최대공약수와 같다. </p><p><strong><code>GCD(a,b) = GCD(b, a % b), (r &gt; 0)일 때</code></strong>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 반복문 이용</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GCD</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> b &gt; <span class="number">0</span>:</span><br><span class="line">        a, b = b, b % a</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 재귀 이용</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GCD</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    r = b % a</span><br><span class="line">    <span class="keyword">if</span> r == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> GCD(b, r)</span><br></pre></td></tr></table></figure><h1 id="최소공배수"><a href="#최소공배수" class="headerlink" title="최소공배수"></a>최소공배수</h1><p> 최소공배수는 최대공약수를 이용하여 구할 수 있다.</p><p><strong><code>lcm(a,b) = a*b/gcd(a,b)</code></strong></p><h2 id="구현-1"><a href="#구현-1" class="headerlink" title="구현"></a>구현</h2><p>위에서 구현한 gcd 함수를 이용하면 쉽게 구현할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LCM</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a * b // GCD(a,b)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/28/gcd-lcm-20200528/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BFS,DFS</title>
      <link>https://hbyyy.github.io/2020/05/22/algo-BFSDFS-20200522/</link>
      <guid>https://hbyyy.github.io/2020/05/22/algo-BFSDFS-20200522/</guid>
      <pubDate>Fri, 22 May 2020 08:30:51 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;이번 포스트에서는 대표적인 그래프 탐색 알고리즘인 BFS(너비 우선 탐색), DFS(깊이 우선 탐색)에 대해 정리할 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;BFS-너비-우선-탐색&quot;&gt;&lt;a href=&quot;#BFS-너비-우선-탐색&quot; class=&quot;headerlink&quot; title=&quot;BFS (너비 우선 탐색)&quot;&gt;&lt;/a&gt;BFS (너비 우선 탐색)&lt;/h2&gt;&lt;p&gt; BFS는 너비 우선 탐색으로, 해당 노드와 같은 레벨에 있는 노드들을 먼저 순회하는 탐색 알고리즘이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>이번 포스트에서는 대표적인 그래프 탐색 알고리즘인 BFS(너비 우선 탐색), DFS(깊이 우선 탐색)에 대해 정리할 것이다.</p></blockquote><h2 id="BFS-너비-우선-탐색"><a href="#BFS-너비-우선-탐색" class="headerlink" title="BFS (너비 우선 탐색)"></a>BFS (너비 우선 탐색)</h2><p> BFS는 너비 우선 탐색으로, 해당 노드와 같은 레벨에 있는 노드들을 먼저 순회하는 탐색 알고리즘이다.</p><a id="more"></a><p><img src="/image/tree1.png" alt=""></p><p> 위의 트리에서, BFS라면 0 - 1 - 2 - 3 - 4 - 5 - 6 순으로 순회할 것이다.</p><h3 id="파이썬으로-그래프-표현"><a href="#파이썬으로-그래프-표현" class="headerlink" title="파이썬으로 그래프 표현"></a>파이썬으로 그래프 표현</h3><ul><li>파이썬에서는 딕셔너리, 리스트를 이용해 그래프를 표현할 수 있다</li><li>인접 리스트, 인접 행렬 두 가지 방법이 있다.</li></ul><p><img src="/image/tree2.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 인접 리스트로 그래프 구현</span></span><br><span class="line">graph = &#123;<span class="string">'A'</span>: [<span class="string">'B'</span>, <span class="string">'C'</span>],</span><br><span class="line">        <span class="string">'B'</span>: [<span class="string">'A'</span>, <span class="string">'D'</span>],</span><br><span class="line">        <span class="string">'C'</span>: [<span class="string">'A'</span>, <span class="string">'G'</span>, <span class="string">'H'</span>, <span class="string">'I'</span>],</span><br><span class="line">        <span class="string">'D'</span>:[<span class="string">'B'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>],</span><br><span class="line">        <span class="string">'E'</span>:[<span class="string">'D'</span>],</span><br><span class="line">        <span class="string">'F'</span>:[<span class="string">'D'</span>],</span><br><span class="line">        <span class="string">'G'</span>:[<span class="string">'C'</span>],</span><br><span class="line">        <span class="string">'H'</span>:[<span class="string">'C'</span>],</span><br><span class="line">        <span class="string">'I'</span>:[<span class="string">'C'</span>, <span class="string">'J'</span>],</span><br><span class="line">        <span class="string">'J'</span>:[<span class="string">'I'</span>]&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS-알고리즘-구현"><a href="#BFS-알고리즘-구현" class="headerlink" title="BFS 알고리즘 구현"></a>BFS 알고리즘 구현</h3><p> BFS를 구현하기 위해 큐를 활용한다.</p><ul><li>need_visit 큐와 visited 큐 두개를 사용</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span><span class="params">(graph, start_node)</span>:</span></span><br><span class="line">    visited = []</span><br><span class="line">    need_visit = []   </span><br><span class="line">    need_visit.append(start_node)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> need_visit:</span><br><span class="line">        node = need_visit.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            visited.append(node)</span><br><span class="line">            need_visit.extend(graph[node])</span><br><span class="line">    <span class="keyword">return</span> visited</span><br><span class="line"></span><br><span class="line"><span class="comment"># pop(0)은 시간복잡도가 O(n)이니, deque를 사용하면 O(1)의 시간복잡도로 pop을 할 수 있다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS2</span><span class="params">(graph, start_node)</span>:</span></span><br><span class="line">    visited = []</span><br><span class="line">    need_visit = deque()   </span><br><span class="line">    need_visit.append(start_node)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> need_visit:</span><br><span class="line">        node = need_visit.popleft()</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            visited.append(node)</span><br><span class="line">            need_visit.extend(graph[node])</span><br><span class="line">    <span class="keyword">return</span> visited</span><br></pre></td></tr></table></figure><h4 id="시간-복잡도"><a href="#시간-복잡도" class="headerlink" title="시간 복잡도"></a>시간 복잡도</h4><p> 시간 복잡도는 while문을 보면 된다</p><p>위 코드에서, while문은 V + E 번 (노드 수 + 간선 수) 만큼 실행된다. 즉, O(V+E)의 시간복잡도를 가진다.</p><h2 id="DFS-깊이-우선-탐색"><a href="#DFS-깊이-우선-탐색" class="headerlink" title="DFS(깊이 우선 탐색)"></a>DFS(깊이 우선 탐색)</h2><p> DFS는 깊이 우선 탐색으로, 해당 노드의 자손 노드들을 먼저 탐색하는 방식이다. 한 노드의 자식을 타고 끝까지 순회한 후, 다시 돌아와서 다른 형제의 자식을 타고 내려가며 순회한다.<br><img src="/image/tree1.png" alt=""></p><p> 위의 트리에서, BFS라면 0 - 1 - 3 - 4 - 2 - 5 - 6 순으로 순회할 것이다.</p><h3 id="DFS-알고리즘-구현"><a href="#DFS-알고리즘-구현" class="headerlink" title="DFS 알고리즘 구현"></a>DFS 알고리즘 구현</h3><ul><li>BFS와 비슷하지만, DFS는 need_visit <strong>스택</strong>과 visited 큐를 사용한다</li></ul><p><img src="/image/tree2.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(graph, start_node)</span>:</span></span><br><span class="line">    visited = []</span><br><span class="line">    need_visit = []</span><br><span class="line">    need_visit.append(start_node)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> need_visit:</span><br><span class="line">        node = need_visit.pop()</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            visited.append(node)</span><br><span class="line">            <span class="comment"># 그래프의 왼쪽부터 순회하기 위해 [::-1]로 넣어준다</span></span><br><span class="line">            <span class="comment"># 무향 그래프이므로 중요하지 않지만, 위의 그림에서 보이는 왼쪽 노드들부터 탐색하기 위해서</span></span><br><span class="line">            need_visit.extend(graph[node][::<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> visited</span><br></pre></td></tr></table></figure><h4 id="시간-복잡도-1"><a href="#시간-복잡도-1" class="headerlink" title="시간 복잡도"></a>시간 복잡도</h4><p> 시간 복잡도는 BFS와 동일하게 O(V + E)이다.</p>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/22/algo-BFSDFS-20200522/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 자료구조 - 컬렉션 자료구조 (셋, 딕셔너리)</title>
      <link>https://hbyyy.github.io/2020/05/19/python-datastructure-ch3-1-20200519/</link>
      <guid>https://hbyyy.github.io/2020/05/19/python-datastructure-ch3-1-20200519/</guid>
      <pubDate>Tue, 19 May 2020 13:44:54 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;이번 포스트에서는 컬렉션 자료구조인 셋과 딕셔너리에 대해 정리할 것이다.&lt;/p&gt;
&lt;p&gt;컬렉션 자료구조는 세 가지 속성을 가진다&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;멤버십 연산자 : in&lt;/strong&gt;, &lt;strong&gt;크기 함수 : len&lt;/strong&gt;, &lt;strong&gt;반복성&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;셋&quot;&gt;&lt;a href=&quot;#셋&quot; class=&quot;headerlink&quot; title=&quot;셋&quot;&gt;&lt;/a&gt;셋&lt;/h2&gt;&lt;p&gt; &lt;strong&gt;셋&lt;/strong&gt;은 반복 가능, 가변적, 중복 요소 없음, 정렬되지 않음 특성을 가진 데이터 타입이다. 주도 &lt;strong&gt;멤버십 테스트&lt;/strong&gt;, &lt;strong&gt;중복 제거&lt;/strong&gt; 를 할 때 사용한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>이번 포스트에서는 컬렉션 자료구조인 셋과 딕셔너리에 대해 정리할 것이다.</p><p>컬렉션 자료구조는 세 가지 속성을 가진다</p><p><strong>멤버십 연산자 : in</strong>, <strong>크기 함수 : len</strong>, <strong>반복성</strong></p></blockquote><h2 id="셋"><a href="#셋" class="headerlink" title="셋"></a>셋</h2><p> <strong>셋</strong>은 반복 가능, 가변적, 중복 요소 없음, 정렬되지 않음 특성을 가진 데이터 타입이다. 주도 <strong>멤버십 테스트</strong>, <strong>중복 제거</strong> 를 할 때 사용한다.</p><a id="more"></a><h3 id="셋-메서드"><a href="#셋-메서드" class="headerlink" title="셋 메서드"></a>셋 메서드</h3><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><p>A.add(x) 는 셋 A에 x가 없을 경우 x를 추가한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>&#125;</span><br><span class="line">s.add(<span class="string">"4"</span>)</span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># 셋은 순서가 없다</span></span><br><span class="line">Out : &#123;<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"2"</span>, <span class="string">"4"</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="update-union"><a href="#update-union" class="headerlink" title="update(), union()"></a>update(), union()</h4><ul><li><p>A.update(B) (A |= B)는  셋 A에 셋 B를 추가한다. </p></li><li><p>A.union(x)(A | B) 은 update와 같지만, 연산 결과를 복사본으로 반환한다.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;</span><br><span class="line">B = &#123;<span class="string">"3"</span>, <span class="string">"4"</span>&#125;</span><br><span class="line"><span class="comment"># update() 메서드</span></span><br><span class="line">A.update(B)</span><br><span class="line">print(A)</span><br><span class="line">Out : &#123;<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># union() 메서드</span></span><br><span class="line">A = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;</span><br><span class="line">C = A.union(B)</span><br><span class="line">print(C)</span><br><span class="line">Out : &#123;<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="intersection-difference-clear"><a href="#intersection-difference-clear" class="headerlink" title="intersection(), difference(). clear()"></a>intersection(), difference(). clear()</h4><ul><li>A.intersection(B)(A&amp;B) 는 A와 B의 교집합의 복사본을 반환한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;</span><br><span class="line">B = &#123;<span class="string">"1"</span>, <span class="string">"3"</span>&#125;</span><br><span class="line">C = A.intersection(B)</span><br><span class="line">print(C)</span><br><span class="line">Out : &#123;<span class="string">'1'</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>A.difference(A-B) 는 A와 B의 차집합의 복사본을 반환한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;</span><br><span class="line">B = &#123;<span class="string">"1"</span>, <span class="string">"3"</span>&#125;</span><br><span class="line">C = A.difference(B)</span><br><span class="line">print(C)</span><br><span class="line">Out : &#123;<span class="string">'2'</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>A.clear()는 A의 모든 항목을 제거한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;</span><br><span class="line">A.clear()</span><br><span class="line">print(A)</span><br><span class="line">Out : &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="discard-remove"><a href="#discard-remove" class="headerlink" title="discard(), remove()"></a>discard(), remove()</h4><ul><li>A.discard(x)는 A의 항목 x를 제거한다. 반환값은  항상 None 이다.</li><li>A.remove(x)는 discard와 같지만, x가 A에 없을 때 KeyError를 발생시킨다.</li></ul><h2 id="딕셔너리"><a href="#딕셔너리" class="headerlink" title="딕셔너리"></a>딕셔너리</h2><p>딕셔너리는 해시 테이블로 구현되어 있다. 셋과 마찬가지로  반복 가능, 가변적, 중복 요소 없음, 정렬되지 않음 특성을 가지고 <strong>키와 값</strong>으로 매핑된 항목의 컬렉션이다.</p><blockquote><p>파이썬 3.7부터는 항목의 삽입 순서를 보존한다.</p></blockquote><h3 id="딕셔너리-메서드"><a href="#딕셔너리-메서드" class="headerlink" title="딕셔너리 메서드"></a>딕셔너리 메서드</h3><h4 id="update-get"><a href="#update-get" class="headerlink" title="update(), get()"></a>update(), get()</h4><ul><li><p>A.update(B) 는 딕셔너리 A에 딕셔너리 B를 추가해 준다. 만약 A에 B의 키가 존재한다면, 기존 키의 값을 업데이트</p></li><li><p>A.get(key, default=None) 은 딕셔너리 A에서 key의 값을 반환한다. key가 없다면 default 값을 반환한다</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = &#123;<span class="number">1</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">2</span>, <span class="number">3</span>:<span class="number">3</span>&#125;</span><br><span class="line">print(A.get(<span class="number">1</span>))</span><br><span class="line">Out : <span class="number">1</span></span><br><span class="line">print(A.get(<span class="number">5</span>))</span><br><span class="line">Out : <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="pop-popitem"><a href="#pop-popitem" class="headerlink" title="pop(), popitem()"></a>pop(), popitem()</h4><ul><li>A.pop(key) 는 key 항목을 제거한 후 반환한다.</li><li>A.popitem()은 A에서 한개의 항목을 제거한 후 반환한다.</li></ul><h4 id="keys-values-items"><a href="#keys-values-items" class="headerlink" title="keys(), values(), items()"></a>keys(), values(), items()</h4><p>딕셔너리의 항목을 조회한다. 각각 키, 값, 키와 값을 반환하는데, 주로 반복문에서 사용한다. </p>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/19/python-datastructure-ch3-1-20200519/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TIL-20200519</title>
      <link>https://hbyyy.github.io/2020/05/19/TIL-20200519/</link>
      <guid>https://hbyyy.github.io/2020/05/19/TIL-20200519/</guid>
      <pubDate>Tue, 19 May 2020 13:42:58 GMT</pubDate>
      <description>
      
        
        
          &lt;ol&gt;
&lt;li&gt;파이썬 자료구조와 알고리즘&lt;ul&gt;
&lt;li&gt;CH 7 연습문제 풀이  (반정도 완료)&lt;/li&gt;
&lt;li&gt;파이썬 컬렉션 자료구조 (셋, 딕셔너리) 복습, 정리&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;

        
      
      </description>
      
      
      <content:encoded><![CDATA[<ol><li>파이썬 자료구조와 알고리즘<ul><li>CH 7 연습문제 풀이  (반정도 완료)</li><li>파이썬 컬렉션 자료구조 (셋, 딕셔너리) 복습, 정리</li></ul></li></ol>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/19/TIL-20200519/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TIL-20200518</title>
      <link>https://hbyyy.github.io/2020/05/18/TIL-20200518/</link>
      <guid>https://hbyyy.github.io/2020/05/18/TIL-20200518/</guid>
      <pubDate>Mon, 18 May 2020 13:14:57 GMT</pubDate>
      <description>
      
        
        
          &lt;ol&gt;
&lt;li&gt;&lt;p&gt;파이썬 자료구조와 알고리즘&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CH 7 뒷부분 완료 (우선순위 큐, 연결 리스트)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Github action&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;develop 브랜치에 커밋될 때에도
        
      
      </description>
      
      
      <content:encoded><![CDATA[<ol><li><p>파이썬 자료구조와 알고리즘</p><ul><li>CH 7 뒷부분 완료 (우선순위 큐, 연결 리스트)</li></ul></li><li><p>Github action</p><ul><li>develop 브랜치에 커밋될 때에도 실행되도록 수정</li></ul></li><li><p>Netflex project</p><ul><li>base.py에서 secretmanaget 불러오는 코드 간결하게 수정<ul><li>aws credential 파일에 변경사항 있음!</li></ul></li></ul></li></ol>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/18/TIL-20200518/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 자료구조와 알고리즘 - 추상 데이터 타입(우선순위 큐, 연결 리스트)</title>
      <link>https://hbyyy.github.io/2020/05/18/python-datastructure-ch7-2-20200518/</link>
      <guid>https://hbyyy.github.io/2020/05/18/python-datastructure-ch7-2-20200518/</guid>
      <pubDate>Mon, 18 May 2020 10:52:47 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;이번 포스트에서는 우선순위 큐, 연결 리스트에 대해 정리할 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;우선순위-큐와-힙&quot;&gt;&lt;a href=&quot;#우선순위-큐와-힙&quot; class=&quot;headerlink&quot; title=&quot;우선순위 큐와 힙&quot;&gt;&lt;/a&gt;우선순위 큐와 힙&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;우선순위 큐는 항목마다 우선순위가 있고, 우선순위가 같으면 큐의 순서를 따른다&lt;/li&gt;
&lt;li&gt;우선순위 큐는 주로 힙을 사용해 구현한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;힙&quot;&gt;&lt;a href=&quot;#힙&quot; class=&quot;headerlink&quot; title=&quot;힙&quot;&gt;&lt;/a&gt;힙&lt;/h3&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>이번 포스트에서는 우선순위 큐, 연결 리스트에 대해 정리할 것이다.</p></blockquote><h2 id="우선순위-큐와-힙"><a href="#우선순위-큐와-힙" class="headerlink" title="우선순위 큐와 힙"></a>우선순위 큐와 힙</h2><ul><li>우선순위 큐는 항목마다 우선순위가 있고, 우선순위가 같으면 큐의 순서를 따른다</li><li>우선순위 큐는 주로 힙을 사용해 구현한다.</li></ul><h3 id="힙"><a href="#힙" class="headerlink" title="힙"></a>힙</h3><a id="more"></a><p><img src="https://gmlwjd9405.github.io/images/data-structure-heap/types-of-heap.png" alt="img"></p><ul><li>힙은 각 노드가 하위 노드보다 작은 or 큰 이진 트리이다.</li></ul><p>리스트에서 가장 작은(또는 큰) 값에 반복적으로 접근해햐 한다면 힙이 유용하다.</p><p>최대 힙, 최소 힙에서 각각 최댓값, 최솟값은 루트 노드에 위치하고 있으니, 이 요소를 처리하는 시간복잡도는 O(1)이다. </p><p>조회, 추가, 수정을 처리하는 시간복잡도는 O(logn)이다. </p><h3 id="heapq-모듈"><a href="#heapq-모듈" class="headerlink" title="heapq 모듈"></a>heapq 모듈</h3><p>파이썬에는 힙 자료구조를 사용할 수 있는 heapq 모듈이 존재한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">h = []</span><br><span class="line"><span class="comment"># 아이템 추가</span></span><br><span class="line">heapq.heappush(h, (<span class="number">5</span>,<span class="string">'55'</span>))</span><br><span class="line">heapq.heappush(h, (<span class="number">6</span>,<span class="string">'66'</span>))</span><br><span class="line">heapq.heappush(h, (<span class="number">1</span>,<span class="string">'11'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 아이템 삭제</span></span><br><span class="line">heapq.headpop(h)</span><br><span class="line">Out : (<span class="number">1</span>, <span class="string">'11'</span>)</span><br><span class="line">heapq.headpop(h)</span><br><span class="line">Out : (<span class="number">5</span>, <span class="string">'55'</span>)</span><br><span class="line">heapq.headpop(h)</span><br><span class="line">Out : (<span class="number">6</span>, <span class="string">'55'</span>)</span><br></pre></td></tr></table></figure><ul><li>메서드<ul><li>heapq.pushpop(heap, item) : 새 item을 힙에 추가한 후 가장 작은 항목을 제거하고 반환</li><li>heapq.merge(*iterables) : 여러개의 이터러블한 객체를 병합해 하나의 정렬된 이터레이터를 반환</li></ul></li></ul><h3 id="Heap-구현"><a href="#Heap-구현" class="headerlink" title="Heap 구현"></a>Heap 구현</h3><ul><li>파이썬 클래스를 이용해 리스트를 이용한 힙을 구현할 수 있다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Max_Heap 구현</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data=None)</span>:</span></span><br><span class="line">        self.data = data <span class="keyword">or</span> []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.data)//<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            self._max_heap_check(i)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> repr(self.data)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parent</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="string">'this node is root node'</span>)</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (i<span class="number">-2</span>)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (i<span class="number">-1</span>)//<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">left_child</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">right_child</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> i*<span class="number">2</span>+<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_max_heap_check</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        largest = i</span><br><span class="line">        print(<span class="string">"start!"</span>, largest)</span><br><span class="line">        left = self.left_child(i)</span><br><span class="line">        right = self.right_child(i)</span><br><span class="line">        n = len(self.data)</span><br><span class="line">        </span><br><span class="line">        largest = (left &lt; n <span class="keyword">and</span> self.data[left] &gt; self.data[i]) <span class="keyword">and</span> left <span class="keyword">or</span> i</span><br><span class="line">        print(largest)</span><br><span class="line">        largest = (right &lt; n <span class="keyword">and</span> self.data[right] &gt; self.data[largest]) <span class="keyword">and</span> right <span class="keyword">or</span> largest</span><br><span class="line">        print(largest)</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">is</span> <span class="keyword">not</span> largest:</span><br><span class="line">            self.data[i], self.data[largest] = self.data[largest], self.data[i]</span><br><span class="line">            print(<span class="string">"----"</span>, largest)</span><br><span class="line">            self._max_heap_check(largest)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(self)</span>:</span></span><br><span class="line">        max_value = self.data[<span class="number">0</span>]</span><br><span class="line">        self.data[<span class="number">0</span>] = self.data[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">del</span> self.data[<span class="number">-1</span>]</span><br><span class="line">        self._max_heap_check(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max_value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        i = len(self.data)</span><br><span class="line">        self.data.append(item)</span><br><span class="line">        <span class="keyword">while</span> (i != <span class="number">0</span>) <span class="keyword">and</span> item &gt; self.data[self.parent(i)]:</span><br><span class="line">            print(<span class="string">"!!!!!!"</span>, self.data)</span><br><span class="line">            self.data[i] = self.data[self.parent(i)]</span><br><span class="line">            i = self.parent(i)</span><br><span class="line">        self.data[i] = item</span><br></pre></td></tr></table></figure><h2 id="연결-리스트"><a href="#연결-리스트" class="headerlink" title="연결 리스트"></a>연결 리스트</h2><p>연결 리스트는 값과 다음 노드에 대한 포인터를 갖는 노드로 이루어진 리스트이다.</p><p>연결 리스트를 이용해 스택, 큐를 구현할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=None, pointer=None)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.pointer = pointer</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getData</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNext</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.pointer</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setData</span><span class="params">(self, newData)</span>:</span></span><br><span class="line">        self.value = newData</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setNext</span><span class="params">(self, newpointer)</span>:</span></span><br><span class="line">        self.pointer = newpointer</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Node 클래스를 이용한 연결 리스트</span></span><br><span class="line">a = Node(<span class="string">"a"</span>)   </span><br><span class="line">b = Node(<span class="string">"b"</span>, a)</span><br><span class="line">b.getNext().getData()</span><br><span class="line">Out : <span class="string">'a'</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/18/python-datastructure-ch7-2-20200518/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TIL-20200516</title>
      <link>https://hbyyy.github.io/2020/05/16/TIL-20200516/</link>
      <guid>https://hbyyy.github.io/2020/05/16/TIL-20200516/</guid>
      <pubDate>Sat, 16 May 2020 13:14:48 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;1-Github-Action&quot;&gt;&lt;a href=&quot;#1-Github-Action&quot; class=&quot;headerlink&quot; title=&quot;1. Github Action&quot;&gt;&lt;/a&gt;1. Github Action&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;master에 커밋
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="1-Github-Action"><a href="#1-Github-Action" class="headerlink" title="1. Github Action"></a>1. Github Action</h1><ul><li>master에 커밋하거나 pull request 를 보냈을 때 자동으로 테스트를 돌리고 codecov 에 upload 하도록 설정했다</li></ul><h2 id="앞으로-해야할-것"><a href="#앞으로-해야할-것" class="headerlink" title="앞으로 해야할 것"></a>앞으로 해야할 것</h2><ul><li>develop 브랜치와 master 브랜치 각각 Github Action 설정하기<ul><li>develop branch (commit, pull request)<ul><li>기능 하나가 완료되서 develop 브랜치에 합쳐진 것이므로, 이 때는 테스트만 자동으로 하도록 수정하자</li></ul></li><li>master branch (commit, pull request)<ul><li>기능 개발이 다 되었고 버전업을 하는 것이니 자동으로 테스트를 돌리고, <strong>자동으로 배포를 하도록</strong> 설정해 보자</li></ul></li></ul></li></ul>]]></content:encoded>
      
      <comments>https://hbyyy.github.io/2020/05/16/TIL-20200516/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
